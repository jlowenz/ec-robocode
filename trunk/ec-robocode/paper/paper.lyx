#LyX 1.4.3 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{footmisc}
\usepackage{float}
\author{Ronald Bowers \& Jason Owens}
\title{Coevolution of Human-Competitive Robocode Tanks Using Genetic Programming with Exogenous Fitness}
\end_preamble
\language english
\inputencoding auto
\fontscheme ae
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 2
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes true
\end_header

\begin_body

\begin_layout Title
Coevolution of Human-Competitive Robocode Tanks Using Genetic Programming
 with Exogenous Fitness
\end_layout

\begin_layout Author
Ronald Bowers & Jason Owens
\end_layout

\begin_layout Date
4 December, 2006
\end_layout

\begin_layout Abstract
In this paper we attempt to evolve software agents that are capable of competing
 successfully against human-coded agents in Robocode battles.
 We use coevolution and genetic programming along with a custom exogenous
 fitness function to perform the experiment.
 An exogenous fitness function is used since previous research into coevolution
 of Robocode agents using only the endogenous function resulted in mediocre
 stable states.
 Although we continue to perform our investigations, we have yet to achieve
 our stated goal.
 The agents are evolving quite successfully with respect to fitness, do
 not seem to have converged, but still do not compete effectively with even
 the simplest human coded agent.
 
\end_layout

\begin_layout Section
Introduction 
\end_layout

\begin_layout Standard
One of the most intriguing ideas in AI is that of learning through self-play.
 Self-play, or 
\begin_inset Quotes eld
\end_inset

introspection
\begin_inset Quotes erd
\end_inset

 is the idea that a machine learning program can come to master some domain
 by repeatedly competing against itself and gradually improving 
\begin_inset LatexCommand \cite{pollack97coevolution}

\end_inset

.
 Most efforts have been unsuccessful, however some, most notably Tesauro's
 TD-Gammon 
\begin_inset LatexCommand \cite{Tesauro:1995vn}

\end_inset

, have greatly succeeded.
 The essential problem with self-play has been that the programs that develop
 tend to be brittle; they cannot compete when then opposition is changed.
\end_layout

\begin_layout Standard
Within the evolutionary computation paradigm, the coevolutionary approach
 provides a means to develop successful programs through self-play, or more
 precisely, through play against other individuals who are also trying to
 improve.
 Traditional self-play can be likened to the old man in the park playing
 both sides of a chess board.
 A coevolutionary approach is more like a chess club in which all start
 as novices and through competition with each other gradually learn to become
 masters.
\end_layout

\begin_layout Standard
There is disagreement in the literature as to the definition of coevolution
 in the context of evolutionary computation.
 In a biological sense, coevolution means two separate species evolving
 together, e.g.
 flowers and bees.
 Many in the EC community hold to the multiple-population concept 
\begin_inset LatexCommand \cite{Floreano:1999dq,koza1991eac}

\end_inset

, and refer to a self-competing population as a competitive fitness environment
 
\begin_inset LatexCommand \cite{angeline93competitive}

\end_inset

.
 Others in the field insist that it is valid to refer to a self-competing
 single population as coevolutionary since each individual is evolving against
 another evolving population, where the other population is the set of all
 other members 
\begin_inset LatexCommand \cite{Luke:2002fk}

\end_inset

.
 Following Luke, we have chosen to use the term coevolution even if only
 one population is involved.
\end_layout

\begin_layout Standard
Coevolution provides the advantage of a non-static fitness landscape: it
 evolves along with the population because the members are competing against
 each other.
 A goal in coevolutionary systems is for the members to evolve in a such
 a way that an 
\begin_inset Quotes eld
\end_inset

arms race
\begin_inset Quotes erd
\end_inset

 develops.
 An arms race is when the opposing members of the population simultaneously
 begin to develop ways to counter their opposition's strengths and exploit
 their vulnerabilities, which ultimately leads to more rapid evolution of
 the system as a whole.
 
\begin_inset Note Note
status open

\begin_layout Standard
do we have references for this?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Although coevolution appears to be a useful way of evolving game-playing
 agents, historically it has not often been successful in games where there
 is a cost or risk in taking action.
 In this situation, a phenomenon called 
\begin_inset Quotes eld
\end_inset

mediocre stable state
\begin_inset Foot
status collapsed

\begin_layout Standard
The "mediocre stable state" is a state where the population consists of
 members who do absolutely nothing.
 This phenomenon occurs because every action away from the initial condition
 incurs a cost.
 Thus, the starting state it is a local optima for all contestants.
\end_layout

\end_inset

" can occur 
\begin_inset LatexCommand \cite{ficici98challenges,waters1999gpa,Shichel:2005eu}

\end_inset

.
 The mediocre stable state has consistently hindered the use of coevolution
 in the development of combat game playing agents.
 One approach to avoiding the mediocre stable state is through the use of
 an appropriate exogenous fitness function
\begin_inset LatexCommand \cite{waters1999gpa}

\end_inset

.
 
\end_layout

\begin_layout Standard
An interesting
\begin_inset Foot
status collapsed

\begin_layout Standard
At least it's interesting from our point of view: evolving autonomous robotic
 agents on a simulated battlefield seems to be at least partially applicable
 to our current positions at the Army Research Lab.
\end_layout

\end_inset

 environment in which to test the efficacy of coevolution is Robocode.
 Robocode is a robot battle simulation game.
 From the SourceForge project page: 
\end_layout

\begin_layout Quote
Robocode is a Java based programming game, where the goal is to develop
 robot battle tanks to battle against competitor tanks.
 The motto of Robocode is: Build the best, destroy the rest!
\end_layout

\begin_layout Standard
Robocode allows a two or more robots to compete, and a score is computed
 to rank the contestants.
 The details of the scoring and its usefulness in coevolution will be discussed
 in 
\begin_inset LatexCommand \ref{sec:Robocode}

\end_inset

.
 
\end_layout

\begin_layout Standard
The problem we are investigating is whether or not one can use coevolution
 to develop agents that can compete successfully against human-coded agents
 in a Robocode battle.
 One aspect of this problem is how we can avoid producing a mediocre stable
 state; a failure in that respect will result in non-competitive robots.
 We had hypothesized that by using genetic programming and coevolution with
 an exogenous fitness function (to motivate the robots to avoid the mediocre
 stable state), we 
\emph on
could
\emph default
 evolve Robocode players that compete successfully against human-designed
 robots.
 Unfortunately, that goal appears harder to achieve than we thought it would
 be.
\end_layout

\begin_layout Section
\begin_inset LatexCommand \label{sec:Robocode}

\end_inset

Robocode
\end_layout

\begin_layout Standard
As stated previously, Robocode is a programming game.
 It provides a framework in which two or more software agents representing
 robotic tanks (usually hand-coded by a programmer), can fight to the death.
 An objective fitness score is provided in order to rank tanks in a match.
 Moving, shooting, colliding with walls & tanks, and getting shot by an
 enemy cost energy.
 Successfully shooting an enemy returns some energy.
 A typical Robocode match consists of ten combat scenarios with the contestants
 starting in random orientations.
 The Robocode distribution comes with a set of relatively simple robots,
 with advanced robots available online.
 There is also a tournament system that allows developers to compete against
 other robots that have been submitted.
\end_layout

\begin_layout Standard
Eisenstein describes the Robocode environment as a mixture of realism and
 fantasy 
\begin_inset LatexCommand \cite{Eisenstein:2003wd}

\end_inset

: it's a simulation, so there are complex time-dependent relationships between
 actions and effects, but it's also a relatively 
\emph on
simple
\emph default
 simulation with 
\begin_inset Quotes eld
\end_inset

advanced
\begin_inset Quotes erd
\end_inset

 sensors, no noise, and a flat, finite, two dimensional world surrounded
 by walls.
\end_layout

\begin_layout Standard
Each robot executes in its own thread and is event driven.
 The Robocode system synchronizes robot actions and sends messages to a
 robot when various events occur.
 These events include:
\end_layout

\begin_layout Description
ScannedRobot detecting an enemy tank
\end_layout

\begin_layout Description
HitByBullet getting hit by a bullet
\end_layout

\begin_layout Description
WallCollision running into a wall 
\end_layout

\begin_layout Description
RobotCollision running into another robot 
\end_layout

\begin_layout Description
BulletHit hitting another robot with your bullet 
\end_layout

\begin_layout Description
BulletMiss missing any robot with your bullet
\end_layout

\begin_layout Standard
A robot responds to an event with some combination of logic and action execution.
 Any actions are enqueued and subsequently take some time to execute.
 If another event occurs before the first set of actions is completed, the
 actions inspired by the second event are layered on top of the previous
 set and they execute together.
 This interaction between actions, events and the executed response of the
 robot makes designing Robocode robots by hand difficult.
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Subsection
Coevolution
\end_layout

\begin_layout Standard
There has been considerable study of coevolution in evolutionary computation.
 The efforts include research into both multiple population and single populatio
n coevolution.
 
\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand \cite{angeline93competitive}

\end_inset

, Angeline and Pollock argue that competitive fitness functions are more
 effective than independent fitness functions.
 A competitive fitness function is considered to be any calculation of fitness
 that is dependent on the current state of the population, rather than relative
 to a global optimum.
 Generally, competitive fitness is measured through competition between
 population members.
 These competitions can range from testing each member against each other
 to a carefully structured tournament 
\begin_inset LatexCommand \cite{angeline93competitive}

\end_inset

.
 
\end_layout

\begin_layout Standard
Floreano, Nolfi and Mondada 
\begin_inset LatexCommand \cite{Floreano:1999dq}

\end_inset

 found that competitive coevolution can generate efficient chasing and escaping
 strategies in a predator/prey environment.
 They also found that this capability evolved even more quickly than "simple"
 wall avoidance They postulate that competitive coevolution generates solutions
 to difficult problems by generating a series of challenges of increasing
 difficulty.
\end_layout

\begin_layout Standard
Uchibe and Asasa 
\begin_inset LatexCommand \cite{Uchibe:2006qe}

\end_inset

 were able to use coevolution to evolve both competitive and cooperative
 behaviors in soccer playing robots.
\end_layout

\begin_layout Standard
Unfortunately, there are several potential drawbacks to a coevolutionary
 approach.
 The most frequently cited drawback is the learned phenomenon called a 
\begin_inset Quotes eld
\end_inset

mediocre stable state.
\begin_inset Quotes erd
\end_inset

 Ficici and Pollack 
\begin_inset LatexCommand \cite{ficici98challenges}

\end_inset

 found that other difficulties include the need to maintain balance in the
 arms race.
 If the arms race becomes imbalanced, one challenger will be unable to offer
 continued opposition.
 This will slow down or halt the evolution.
 Another issue is that the environment should neither be too easy nor too
 difficult: if the environment is too easy, the population members will
 not be stressed enough to improve; on the other hand, if the environment
 is too hard members will be too stressed; this can lead to low fitness
 and make it difficult to progress.
 They concluded that open-ended coevolution is not necessarily synonymous
 with a purely competitive framework.
 Instead, it's necessary to provide a mixture of competitive and cooperative
 pressures in order to avoid the mediocre stable state.
\end_layout

\begin_layout Standard
Some research has indicated promising techniques that might help to guide
 the coevolutionary process and thus avoid some of the previously-mentioned
 problems.
 De Jong and Pollack 
\begin_inset LatexCommand \cite{dejong2004iec}

\end_inset

 investigated fitness evaluation in coevolutionary systems.
 They found that a problem might consist of multiple competing objectives.
 They also found that it was possible to determine the complete evaluation
 set.
 This set can be used as a 
\begin_inset Quotes eld
\end_inset

perfect teacher
\begin_inset Quotes erd
\end_inset

 that can determine whether one member is dominated by another.
 
\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand \cite{waters1999gpa}

\end_inset

, an exogenous fitness function was proposed.
 Whereas an endogenous fitness function is one provided by the environment
 itself, in their case the programming game AI Wars, an exogenous fitness
 function is one that is specified by the investigators (an example of inductive
 bias) in an effort to guide the evolutionary process.
 Their exogenous fitness function looked for certain specific acts performed
 by the agent.
 The base endogenous score was then modified: positively for good acts,
 negatively for bad acts.
 By using this exogenous fitness function they were able to induce the aggressiv
e behavior that they desired.
\end_layout

\begin_layout Subsection
Genetic Programming
\end_layout

\begin_layout Standard
Genetic programming has been successfully used to develop software agents.
 In 
\begin_inset LatexCommand \cite{Koza:1992bh}

\end_inset

, Koza and Rice describe the development of a robot that could move a box
 around a room by pushing it.
 Their efforts were successful, as the robot eventual grew to be able to
 move the box, and account for issues such as rotation of the box due to
 an off-axis bump.
\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand \cite{montana93strongly}

\end_inset

, Montana develops a strongly-typed genetic programming (STGP) system.
 While still tree-base, his system differs from the Koza's standard approach
 in two primary aspects.
 First, the representation includes specified types for each variable and
 constant as well as the parameters and return value for all functions.
 This change in representation was used to ensure that all generated trees
 had no type-mismatch errors.
 Second, the initial population cannot be generated completely randomly;
 rather, it had to adhere to the typing rules.
 
\end_layout

\begin_layout Standard
Some research has been performed using genetic programming systems that
 were not tree-based.
 These efforts include 
\begin_inset LatexCommand \cite{Eisenstein:2003wd}

\end_inset

, 
\begin_inset LatexCommand \cite{waters1999gpa}

\end_inset

 and 
\begin_inset LatexCommand \cite{lucas:ero}

\end_inset

.
 In 
\begin_inset LatexCommand \cite{Eisenstein:2003wd}

\end_inset

, Eisenstein evolves agents for Robocode using his own custom-designed TableRex
 language based on Leslie Kaelbling's REX language.
 In 
\begin_inset LatexCommand \cite{waters1999gpa}

\end_inset

, Waters and Sheppard experimented in the AI Wars game environment.
 AI Wars bugs are controlled by blocks of procedural code.
 They used five mutation operators and a crossover operator to modify the
 code blocks.
 Finally, in 
\begin_inset LatexCommand \cite{lucas:ero}

\end_inset

, Lucas begins the investigation of how one can use the plethora of existing
 object-oriented class libraries in GP solutions.
 He proposes to use reflection to allow GP programs to discover and use
 existing software.
 This work is in its earliest stages.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
\begin_inset LatexCommand \label{sub:Robocode-based-Investigations}

\end_inset

Robocode-based Investigations
\end_layout

\begin_layout Standard
There have been several projects which have attempted to evolve Robocode
 combatants.
 
\begin_inset LatexCommand \cite{Eisenstein:2003wd,Hong:2004rr,Shichel:2005eu}

\end_inset

.
 Each of these efforts have used a different control architecture, and none
 has successfully used coevolution.
\end_layout

\begin_layout Standard
Eisenstein 
\begin_inset LatexCommand \cite{Eisenstein:2003wd}

\end_inset

 built his Robocode tank using a subsumption architecture that was evolved
 using a GA.
 Coevolution was attempted, but failed to produce any progress towards competiti
ve robots.
 Indeed, he says 
\begin_inset Quotes eld
\end_inset

after several generations, I found the population rife with catatonics.
\begin_inset Quotes erd
\end_inset

 The experiment proceeded using the standard Robocode robots plus one high-perfo
rmance robot as the opposition.
 Eisenstein also explicitly points out that targeting behaviors were very
 hard to evolve.
 
\end_layout

\begin_layout Standard
The robots were evolved in four, increasingly complex, environments.
\end_layout

\begin_layout Itemize
Single adversary, single starting position
\end_layout

\begin_layout Itemize
Single adversary, multiple starting positions
\end_layout

\begin_layout Itemize
Multiple adversaries
\begin_inset Foot
status collapsed

\begin_layout Standard
Multiple adversaries means that a combination of pre-defined tanks were
 fought.
 Combat was still one-on-one.
\end_layout

\end_inset

, single starting position
\end_layout

\begin_layout Itemize
Multiple adversaries, multiple starting positions
\end_layout

\begin_layout Standard
For the single adversary, single starting position case, robots that could
 reliably defeat their opposition evolved quickly.
 However, as the complexity of the environment increased, success became
 less common.
 Hindering the process was the fact that the more complex simulations took
 much longer to run.
\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand \cite{Hong:2004rr}

\end_inset

, Hong and Cho used a GA that consisted of six chromosomes, each of which
 had six genes.
 The chromosomes were related to the behavior the tank would exhibit in
 the main loop and in five of the event handlers.
 Each gene corresponded to a specific action-type of the tank, for example
 
\emph on
\noun on
move
\emph default
\noun default
 and 
\emph on
\noun on
shoot
\emph default
\noun default
.
 For each action, two or more hand-coded strategies were developed.
 They were able to evolve tanks that could compete successfully against
 three of the basic tanks, but they had little success in defeating a more
 advanced tank.
\end_layout

\begin_layout Standard
A third experiment was performed by Shichel, Ziserman, and Sipper
\begin_inset LatexCommand \cite{Shichel:2005eu}

\end_inset

.They chose to limit their investigation to a particular class of Robocode
 robot, the 
\noun on
Haiku bot
\noun default
.
 The Haiku bot is limited to four lines of custom code, where the number
 of lines is indicated by the number of semicolons.
 After investigating and rejecting Strongly Typed Genetic Programming and
 Automatically Defined Functions, they chose a Koza-style LISP implementation.
 This had the extra benefit of allowing complex expressions since the the
 Haiku bot class places no limit on the number of parentheses (and thus
 the size of the expression).
 After completing the evolution process, the highest performing robot was
 entered into the Robocode Haiku Bot tournament.
 Remarkably, it finished third out of 27 contestants, where all other contestant
s were hand-coded.
 
\end_layout

\begin_layout Standard
Shichel, Ziserman, and Sipper also investigated coevolution, but found that
 the coevolved robots showed primitive behavior and were easily defeated
 by human-coded robots.
 To overcome the mediocre steady state that arose rapidly in Eisenstein's
 work, they propose in future work to bootstrap the evolutionary process
 with competition against human-coded robots.
 After a few generations in this configuration, they would switch to a coevoluti
onary approach.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Approach
\end_layout

\begin_layout Standard
Ignoring the failures of others, we plan to carry through and explore the
 experiment using genetic programming and coevolution in this rather 
\begin_inset Quotes eld
\end_inset

open-ended
\begin_inset Quotes erd
\end_inset

 domain.
 As mentioned in Section\InsetSpace ~

\begin_inset LatexCommand \ref{sub:Robocode-based-Investigations}

\end_inset

, previous research in evolving Robocode agents reported failure when pursuing
 a coevolutionary model, and thus they resorted to training against known
 quantities 
\begin_inset LatexCommand \cite{Eisenstein:2003wd,Shichel:2005eu}

\end_inset

.
 However, in doing this, the danger of evolving specialized players unable
 to handle generalized situations (i.e.
 new players with different tactics) is increased; in fact, 
\begin_inset LatexCommand \cite{Shichel:2005eu}

\end_inset

 mentions observing this exact problem.
 From our point of view, coevolution is obviously more exciting; we believe
 that the lack of an appropriate exogenous fitness function is the primary
 reason the previous ventures failed during coevolution.
 As 
\begin_inset LatexCommand \cite{ficici98challenges}

\end_inset

 states: 
\begin_inset Quotes eld
\end_inset

[t]he key to successful coevolutionary learning is a competitive arms race
 between opposed participants.
 Competitors must be well-matched in skill to force each other to improve.
\begin_inset Quotes erd
\end_inset

 We would like to add that competitors must also be sufficiently 
\emph on
motivated
\emph default
 in order to avoid the mediocre stable-states common to coevolution 
\begin_inset LatexCommand \cite{angeline93competitive,ficici98challenges,waters1999gpa}

\end_inset

.
\end_layout

\begin_layout Standard
The following subsections describe the high-level aspects of our experiment,
 including the representation, operators, evaluation, algorithm configuration,
 and the execution environment.
\end_layout

\begin_layout Subsection
Representation
\end_layout

\begin_layout Standard
The genome for an individual in the population consists of a forest of expressio
n trees.
 Using our knowledge of the Robocode domain, we identified four primary
 tasks for the robot: manage movement, manage the radar, manage turret/targeting
, and manage firing; thus, we require four separate controllers.
 To reduce the complexity of the problem somewhat, we assume that the "robotic
 platform" we are "executing" on accepts the following input from our controller
s: a vector indicating movement, an angle relative to the heading for the
 radar direction, an angle relative to the heading for the turret direction,
 and a boolean/energy pair indicating whether to fire and how much energy
 the bullet should have.
 We believed this assumption would allow the algorithm to converge more
 quickly since it constrains the hyperspace of possible solutions; however,
 it may put an upper bound on the performance of the evolved agents; a deficienc
y that could hinder an agent's capability to beat a human-coded robot.
\begin_inset Note Note
status collapsed

\begin_layout Standard
diagram of robotic platform and inputs to existing controller from GP forest
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each executable tree is recursively constructed of functions (or non-terminals,
 as we prefer) of various arity, and terminals with 0 arity.
 The nodes (both terminals and non-terminals) are strongly typed, after
 an adaptation of strongly-typed genetic programming described in 
\begin_inset LatexCommand \cite{montana93strongly}

\end_inset

.
 Only nodes that return the correct type can be used as a parameter to a
 non-terminal accepting a specific type.
 This complicates the genetic operators somewhat and will be discussed in
 section\InsetSpace ~

\begin_inset LatexCommand \ref{sub:Operators}

\end_inset

.
 
\end_layout

\begin_layout Standard
Tables 
\begin_inset LatexCommand \ref{tab:Sensor-terminals}

\end_inset

--
\begin_inset LatexCommand \ref{tab:Non-terminals}

\end_inset

 list the domain specific nodes for each event tree.
 Symbols present in the tables indicate the argument types and return types:
 
\begin_inset Formula $\theta$
\end_inset

 is an angle in radians, 
\begin_inset Formula $\delta$
\end_inset

 is a distance, 
\begin_inset Formula $\lambda$
\end_inset

 is an abstract level, 
\begin_inset Formula $\epsilon$
\end_inset

 is an energy level, 
\begin_inset Formula $\beta$
\end_inset

 is a boolean value, 
\begin_inset Formula $\vec{v}$
\end_inset

 is a two-dimensional vector, and 
\begin_inset Formula $\tau$
\end_inset

 is a generic type.
 
\end_layout

\begin_layout Standard
In addition to the domain-specific nodes, there are a few 
\begin_inset Quotes eld
\end_inset

standards
\begin_inset Quotes erd
\end_inset

 that we include as well, described in Table\InsetSpace ~

\begin_inset LatexCommand \ref{tab:Standard-non-terminals}

\end_inset

.
 All of the generic arithmetic nodes can operate on any pair of scalar numeric
 types (i.e.
 angle, distance, energy level).
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Syntax
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Returns
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
add 
\begin_inset Formula $\tau$
\end_inset

 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
sub 
\begin_inset Formula $\tau$
\end_inset

 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
mult 
\begin_inset Formula $\tau$
\end_inset

 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
div 
\begin_inset Formula $\tau$
\end_inset

 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\tau<\tau$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\tau>\tau$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta\wedge\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta\vee\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\neg\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
if-then-else 
\begin_inset Formula $\beta$
\end_inset

 
\begin_inset Formula $\tau$
\end_inset

 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
First if 
\begin_inset Formula $\beta=T$
\end_inset

 else second
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
rand-for-type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
random 
\begin_inset Formula $\tau$
\end_inset

 value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
erc-for-type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
constant 
\begin_inset Formula $\tau$
\end_inset

 value
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{tab:Standard-non-terminals}

\end_inset

Standard nodes
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide true
sideways false
status collapsed

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="22" columns="3">
<features>
<column alignment="left" valignment="top" width="30line%">
<column alignment="center" valignment="top" leftline="true" width="10line%">
<column alignment="left" valignment="top" leftline="true" width="50line%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Syntax
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Returns
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
isMoving
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Is the robot moving?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
currentVector
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Where is the robot is currently going?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
isTurretMoving
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Is the robot's turret moving?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
currentTurretHeading
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Where is the turret currently pointing?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
isRadarMoving
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Is the robot's radar moving?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
currentRadarHeading
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Where is the radar currently pointing?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
energyLevel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\epsilon$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
The robot's current energy level.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
gunHeat
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\lambda$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
The gun's heat (can't fire unless 
\begin_inset Formula $\lambda=0$
\end_inset

 ).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
vectorToForwardWall
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
The vector to the wall directly in front of the robot.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
vectorToNearestWall
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
The vector to the nearest wall, relative to the robot's heading.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
recentlyHitWall
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Did the robot hit the wall since the last time this sensor was read?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
recentlyHitByBullet
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Was the robot hit by a bullet since the last time this sensor was read?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
recentlyRammed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Was the robot rammed since the last time this sensor was read?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
myFault
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Was the ramming my fault?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
bulletBearing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Where did the bullet come from (relative to robot heading when hit).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
bulletEnergy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\epsilon$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
How much energy did the bullet have?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
bulletSpeed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\omega$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
How fast are bullets?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
rammerBearing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Where did the ramming robot come from (relative to robot heading when hit).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
lastVectorToEnemy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Vector to the last known location of the enemy.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
lastHeadingOfEnemy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
The last known direction the enemy was heading.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
lastSpeedOfEnemy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\omega$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
The last known speed of the enemy.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{tab:Sensor-terminals}

\end_inset

Sensor terminals
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide true
sideways false
status collapsed

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features>
<column alignment="left" valignment="top" rightline="true" width="30line%">
<column alignment="center" valignment="top" rightline="true" width="10line%">
<column alignment="left" valignment="top" width="50line%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Syntax
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Returns
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
toVector 
\begin_inset Formula $\theta$
\end_inset

 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Calculates the vector that represents the given heading and distance relative
 to the robot's current heading.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
rotateVector 
\begin_inset Formula $\vec{v}$
\end_inset

 
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Calculates a new vector by rotating it the given amount.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
scaleVector 
\begin_inset Formula $\vec{v}$
\end_inset

 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Calculates a new vector by scaling it the given amount.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
vectorLength 
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Calculates the length of the vector.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
vectorHeading 
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Calculates the heading of the vector relative to the robot's heading.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{tab:Non-terminals}

\end_inset

Non-terminals
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset LatexCommand \label{sub:Operators}

\end_inset

Operators
\end_layout

\begin_layout Standard
We use two reproductive operators: crossover and mutation.
 As noted earlier, the standard GP versions of these operators will not
 work in our case, since any given node may not be compatible with any other
 node due to a type mismatch.
 Therefore, both operators are modified to explicitly support the strong
 typing.
 In addition, the operators will only operate between like chromosomes (e.g.
 the movement tree).
\end_layout

\begin_layout Subsubsection
Crossover
\end_layout

\begin_layout Standard
The crossover operator takes 2 parent trees and produces 2 offspring created
 by swapping randomly chosen subtrees between parents.
 As described in 
\begin_inset LatexCommand \cite{montana93strongly}

\end_inset

, a random node is picked from tree A to serve as the root of the swapped
 subtree 
\begin_inset Formula $\alpha$
\end_inset

.
 Now a subtree must picked from tree B.
 However, due to the requirement of matching the parent type of subtree
 
\begin_inset Formula $\alpha$
\end_inset

, subtree 
\begin_inset Formula $\beta$
\end_inset

 cannot be chosen from any node.
 It must be randomly chosen from the set of nodes having the appropriate
 type.
 If 1 or more matching nodes exist, one is chosen randomly as the root of
 subtree 
\begin_inset Formula $\beta$
\end_inset

, otherwise the operator returns the parents or nothing.
\end_layout

\begin_layout Subsubsection
Mutation
\end_layout

\begin_layout Standard
Even though mutation is typically omitted from a GP with the claim that
 it adds little utility 
\begin_inset LatexCommand \cite{Sheppard:2006fk}

\end_inset

, we choose to include it for several reasons.
 We like the idea that mutation helps us explore the entire search space
 (which crossover just can't do), and since we will probably be using a
 relatively small population size due to time constraints and minimal computatio
nal resources, mutation will help since it's unlikely that all valid operations
 will exist in the initial population.
 For example, consider an operator that takes a value, such as (add 
\begin_inset Formula $\alpha$
\end_inset

 
\begin_inset Formula $\beta$
\end_inset

).
 The amount to add is specified as an argument.
 Crossover and reproduction cannot explore how much to add unless all parameter
 values are represented in the initial population.
 It is more practical to allow mutation of such parameters.
 
\end_layout

\begin_layout Standard
The mutation operator itself will consist of all four primary variations
 
\begin_inset LatexCommand \cite{Sheppard:2006fk}

\end_inset

 (grow, shrink, cycle and switch) as well as a custom variation to operate
 on the constant numerical values that can be present in our trees.
 As was the case with crossover, the 4 tree variations must be modified
 to handle the strong typing constraints.
 For example, the cycle variation may only choose from nodes that match
 what the existing parent node expects.
 Since the custom variation only deals with numerical constants, it 
\begin_inset Quotes eld
\end_inset

automatically
\begin_inset Quotes erd
\end_inset

 handles the typing constraints.
\end_layout

\begin_layout Standard
The custom variation will be based on real-valued mutation, where the general
 form is 
\begin_inset Formula $x'=x+m$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

 is a random value such that 
\begin_inset Formula $m\sim U(a,b)$
\end_inset

 where 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 are lower and upper bounds 
\begin_inset LatexCommand \cite{Sheppard:2006fk}

\end_inset

, configurable per type.
\end_layout

\begin_layout Subsection
Evaluation and Fitness Functions
\end_layout

\begin_layout Standard
Our implementation of coevolution follows that of the model described in
 
\begin_inset LatexCommand \cite{Luke:2002fk}

\end_inset

: one-population coevolution, where single individuals compete with every
 other individual to obtain an overall fitness value.
 Thus, the evaluation of fitness for each individual will be calculated
 by matching that individual against all other individuals in the population,
 including itself (we see no reason to exclude this self-play from the evaluatio
n stage) where the resulting fitness value will be calculated as the average
 fitness over all matches.
 A match consists of a set of 10 two player tank-to-tank combat scenarios,
 with random starting orientations selected for each scenario.
 The match score will be the median fitness value from the sequence of combat
 scenarios.
\end_layout

\begin_layout Standard
As mentioned previously, we believe the failures encountered with previous
 explorations of genetically programmed Robocode agents under coevolution
 occurred due to the use of the natural endogenous fitness function: the
 score provided by Robocode.
 This score is based on various factors including: survival relative to
 other robots, last robot alive bonus, bullet damage to enemies, bullet
 kill bonus, ram damage to enemies, and ram kill bonus 
\begin_inset LatexCommand \cite{Nelson:2006kx}

\end_inset

.
 Note that firing a bullet, getting hit by a bullet, ramming a robot (or
 getting rammed), and colliding with a wall all cause 
\begin_inset Quotes eld
\end_inset

damage
\begin_inset Quotes erd
\end_inset

 in the form of reducing the overall energy level of the robot.
 When the energy level drops to zero, the robot is dead.
 Since robots in a coevolutionary environment start at about the same level
 with very primitive movement, firing, targeting and scanning skills, the
 most productive thing (i.e.
 the one generating the highest relative score) to do is sit still.
 Even though successfully shooting an enemy is rewarded, the primitive skills
 prevent accuracy, and thus simply waste energy.
 The best successful strategy in this situation is to do nothing: a mediocre
 stable state.
 
\end_layout

\begin_layout Subsection
Tuning the Exogenous Fitness Function
\end_layout

\begin_layout Standard
We have developed and tested several exogenous fitness functions in the
 hopes of finding one that guides our robots in the desired evolutionary
 direction.
 As was stated previously, we eschewed the endogenous Robocode score because
 it favors energy conservation in general and using it in a coevolutionary
 system can easily lead to mediocre stable states.
 In this section we will describe the functions we tried, the motivation
 for each function, and, for the earlier functions, the observed outcome.
\end_layout

\begin_layout Subsubsection
The First Fitness Function
\end_layout

\begin_layout Standard
Our initial fitness function was based on the idea that the robots should
 shoot and not get shot.
 Thus we formulated the simple equation:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
F=W_{d}\cdot b_{dodged}+W_{f}\cdot b_{fired}\]

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $b_{\mathit{fired}}$
\end_inset

 is the count of bullets fired, 
\begin_inset Formula $b_{dodged}$
\end_inset

 is defined in 
\begin_inset LatexCommand \ref{eq:dodged}

\end_inset

, and 
\begin_inset Formula $W_{d}=1$
\end_inset

 and 
\begin_inset Formula $W_{f}=1$
\end_inset


\begin_inset Formula \begin{equation}
b_{dodged}=b_{\mathit{fired\, by\, opponent}}-b_{hit\; by\; opponent}\label{eq:dodged}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
This fitness function was an absolute failure.
 It quickly led to robots that shot wildly, but generally took no other
 action.
 The 
\begin_inset Formula $b_{dodged}$
\end_inset

 term dominated the fitness value because any errant shot gave the opponent
 a point for dodging, even if they did nothing.
 This function was quickly abandoned.
\end_layout

\begin_layout Subsubsection
The Second Fitness Function
\end_layout

\begin_layout Standard
With the second fitness function we attempted to coax our robots to include
 three additional desired behaviors: movement, enemy sensing, and wall avoidance.
 The function was:
\begin_inset Formula \begin{equation}
F=\begin{array}{cc}
W_{f}\cdot b_{fired}+W_{d}\cdot b_{dodged}+\\
W_{h}\cdot h+W_{s}\cdot s+W_{m}\cdot m\end{array}\label{eq:fit2}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $W_{f}=1.5$
\end_inset

, 
\begin_inset Formula $W_{d}=1.0$
\end_inset

, 
\begin_inset Formula $W_{h}=-2.0$
\end_inset

, 
\begin_inset Formula $W_{s}=1.0$
\end_inset

, and 
\begin_inset Formula $W_{m}=0.1$
\end_inset

 are the weights for bullets fired, bullets dodged, walls hit, number of
 enemy scans, and distance travelled (movement) respectively, while the
 new values 
\begin_inset Formula $h$
\end_inset

, 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

 are the number of registered wall hits, scans of the enemy and raw distance
 travelled.
 This fitness did improve upon the first, in that the bots learned to keep
 moving (and move great distances at that), generally avoid walls, fire
 all the time and spin their radars constantly.
 They rapidly converged to this state, and didn't make much progress after
 that.
\end_layout

\begin_layout Subsubsection
The Third Fitness Function
\end_layout

\begin_layout Standard
The third fitness function was the first to take Robocode wins into consideratio
n.
 It also adjusted the distance measurement to better compare values.
 The 
\begin_inset Formula $m$
\end_inset

 term in equation 
\begin_inset LatexCommand \ref{eq:fit2}

\end_inset

 was replaced with:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
m=\frac{d_{robot}}{d_{robot}+d_{opponent}}\]

\end_inset


\end_layout

\begin_layout Standard
a ratio of distance travelled relative to the total distance travelled of
 each robot.
 Thus, the weight was adjusted to 
\begin_inset Formula $W_{m}=100$
\end_inset

.
 The additional wins term took the form: 
\begin_inset Formula $W_{w}\cdot w$
\end_inset

 where 
\begin_inset Formula $w$
\end_inset

 was the number of times the robot won the battle (out of the 10 stochastic
 rounds) and 
\begin_inset Formula $W_{w}=100$
\end_inset

 as well.
 This function also improved somewhat on the previous fitness, since it
 deemphasized the distance and actually took into consideration whether
 a robot beat the opponent.
 However, the bots still converged to suboptimal behavior, which primarily
 took the form of heading toward walls and firing all the time.
\end_layout

\begin_layout Subsubsection
The Final Fitness Function
\end_layout

\begin_layout Standard
Our current exogenous fitness function emphasizes the damage inflicted on
 the opponent.
 The fitness function is:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
F=\frac{wins}{10}\cdot\left(F_{damage}+F_{tweek}\right)+F_{activity}\]

\end_inset


\end_layout

\begin_layout Standard
The term 
\begin_inset Formula $F_{damage}$
\end_inset

is the contribution to fitness from the damage inflicted by the robot.
 It is defined as:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
F_{damage}=\begin{array}{cc}
D_{bullet}+D_{ram}+B_{bullet}+B_{ram}+\\
e_{bullet}D_{bullet}+e_{scan}D_{bullet}\end{array}\]

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $D_{bullet}$
\end_inset

 is the damage inflicted by this robot against its opponent, and 
\begin_inset Formula $D_{ram}$
\end_inset

 is the damage inflicting by ramming the opponent.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
These scores are provided by Robocode.
 The terms 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default

\begin_inset Formula $B_{bullet}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
 and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default

\begin_inset Formula $B_{ram}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
 are bonuses given by Robocode for killing the opponent by bullet or by
 ramming, respectively.
 The bonuses are also provided by Robocode.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
The term 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default

\begin_inset Formula $e_{bullet}$
\end_inset

 is bonus multiplier based on shot accuracy.
 It is defined by: 
\end_layout

\begin_layout Standard
\begin_inset Formula \[
e_{bullet}=5\cdot\frac{Hits}{Bullets\: Fired}\]

\end_inset


\end_layout

\begin_layout Standard
The intent of the bullet efficiency term is to overcome the tendency to
 shoot wildly that was seen when using the first fitness function.
 Similarly, 
\begin_inset Formula $e_{scan}$
\end_inset

is a multiplier for scan efficiency.
 Scan efficiency expresses the number of 
\begin_inset Quotes eld
\end_inset

Enemy Scanned
\begin_inset Quotes erd
\end_inset

 events as a function of the angular distance the radar turns.
 The purpose of this term is to overcome the tendency to simply spin the
 radar and to keep the radar pointed towards the enemy instead.
 Scan efficiency is defined by:
\begin_inset Formula \[
revs=\frac{Total\: Radians\: Turned}{2\pi}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
e_{scan}=\frac{Scan\; Events-revs}{4\cdot revs}\]

\end_inset


\end_layout

\begin_layout Standard
To compute the efficiency metrics and 
\begin_inset Formula $F_{tweek}$
\end_inset

, Robocode was modified to record the number of shots, the number of hits,
 the radians the radar turns, the number of scan events, and the total distance
 travelled.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $F_{tweek}$
\end_inset

 term is intended to give the robot some credit for moving, shooting, and
 scanning.
 The use of logarithms slows the growth of 
\begin_inset Formula $F_{tweek}$
\end_inset

 and prevents it from overwhelming the 
\begin_inset Formula $F_{damage}$
\end_inset

 score.
 It is defined as:
\begin_inset Formula \begin{eqnarray*}
F_{tweek} & = & \ln\left(Shots\; Fired\right)+\\
 &  & \ln\left(Scan\; Events\right)+\\
 &  & \ln\left(Distance\; Traveled\right)\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Since the 
\begin_inset Formula $F_{damage}$
\end_inset

 and 
\begin_inset Formula $F_{tweek}$
\end_inset

 scores are scaled by the winning percentage, and wins is a Robocode-provided
 metric, it is possible for a robot that has a good
\begin_inset Formula $F_{damage}$
\end_inset

 and 
\begin_inset Formula $F_{tweek}$
\end_inset

 to have its fitness zeroed by losses.
 To avoid this, a small bonus, 
\begin_inset Formula $F_{activity}$
\end_inset

, is added to a robot that moves, shoots, or scans during the battle.
 The value of 
\begin_inset Formula $F_{activity}$
\end_inset

 is a constant 5.0
\end_layout

\begin_layout Subsection
GP Algorithm Configuration
\end_layout

\begin_layout Subsubsection
Initial Tree Creation
\end_layout

\begin_layout Standard
We generate tree's using Koza's 
\emph on
ramped half-and-half
\emph default
 method (described in 
\begin_inset LatexCommand \cite{Luke:2001kx}

\end_inset

), which is apparently the de facto standard for tree initialization.
 This method generates trees by randomly choosing a depth from a pre-configured
 depth range, then probabilistically choosing either the GROW or FULL generation
 method.
 The GROW algorithm is essentially the same as the grow mutation variation,
 randomly choosing non-terminals and terminals to generate a tree up to
 the depth range.
 FULL differs from the GROW algorithm by always choosing non-terminals in
 order to always generate full trees.
 Each tree in our forest-based genome can have it's own set of parameters
 (max/min depth), however we set them all equal.
\end_layout

\begin_layout Subsubsection
Selection and Replacement
\end_layout

\begin_layout Standard
We select individuals using the ranked-order method.
 Replacement is generational, with elitism 
\begin_inset LatexCommand \cite{Sheppard:2006uq}

\end_inset

.
 Specific parameters are shown in Table\InsetSpace ~

\begin_inset LatexCommand \ref{tab:Algorithm-parameters}

\end_inset

.
 As is the case in many evolutionary computation experiments, we have tweak
 the parameters several times during our investigations.
\end_layout

\begin_layout Subsubsection
Parameters
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Might want to compare proposed and used.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features>
<column alignment="left" valignment="top" rightline="true" width="30col%">
<column alignment="center" valignment="top" width="25col%">
<column alignment="center" valignment="top" leftline="true" width="30col%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Proposed Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Final Value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Population Size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
100
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
footnotemark
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
24
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
footnotemark
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Maximum Generations
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
See Section\InsetSpace ~

\begin_inset LatexCommand \ref{sub:Termination-Criteria}

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
See Section\InsetSpace ~

\begin_inset LatexCommand \ref{sub:Termination-Criteria}

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Crossover rate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Mutation rate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.05
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Reproduction rate (direct copy of parents)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Elitism
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Top 10 percent
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Top 2 members
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Maximum initial tree depth
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Maximum tree depth after crossover & mutation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No limit
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{tab:Algorithm-parameters}

\end_inset

Algorithm parameters
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
footnotetext{The population size is so small due to the nature of the evaluation
: there will be $
\backslash
frac{n^2}{2}$ matches, where a match consists of 10 combat scenarios.
 Thus, the total number of game "runs" per generation will be 50000, and
 if each run takes .5 seconds, it's still 6.9 cpu hours per generation.}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset LatexCommand \label{sub:Execution-Environment}

\end_inset

Execution Environment 
\end_layout

\begin_layout Standard
Given a population size of 24, and allowing for self-play, 300 fitness evaluatio
ns are necessary for each generation.
 If all Robocode battles ran in 5 seconds, which is optimistic, processing
 1024 generations would take 17.36 days.
 In order to perform the large number of fitness evaluations necessary in
 the time available, we implemented an architecture that allows us to distribute
 our fitness evaluations across multiple computers.
\end_layout

\begin_layout Standard
The architecture we have developed (shown in Figure 
\begin_inset LatexCommand \ref{fig:Simple-architecture-illustration}

\end_inset

) is based on a simple master-worker pattern.
 The workers consist of instances of Robocode that have been slightly modified.
 The master is a custom driver program.
 Communication between the master and the workers is conducted through a
 JavaSpace.
 The operation of the architecture is:
\end_layout

\begin_layout Enumerate
The driver program generates the initial population.
\end_layout

\begin_layout Enumerate
The driver program generates a series of tasks that specify a battle to
 be fought.
 One task is generated for each robot pairing.
 The task contains the eight GP trees necessary to define the behavior of
 the two competing robots.
\end_layout

\begin_layout Enumerate
The tasks are submitted to the JavaSpace.
\end_layout

\begin_layout Enumerate
The Robocode workers pull the battle tasks from the space and execute them.
\end_layout

\begin_layout Enumerate
When each battle concludes, the Robocode worker calculates the fitness of
 the two contestants and submits a results object to the space.
\end_layout

\begin_layout Enumerate
The driver program pulls the results from the space.
\end_layout

\begin_layout Enumerate
Selection and reproduction is performed by the driver.
\end_layout

\begin_layout Enumerate
The process repeats with the new population.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename javaspace.pdf
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:Simple-architecture-illustration}

\end_inset

Simple architecture illustration
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Several modification have been made to Robocode in order to integrate it
 with this architecture.
 These changes enable Robocode to read battle tasks from the JavaSpace and
 to put the battle results into the space.
 Additional changes were necessary to collect data for the exogenous fitness
 function.
 Some small performance enhancements also have been made.
 The system configuration for our final run consisted of 15 hosts with a
 total of 59 processors.
 Using this configuration, processing one generation took between 30 and
 90 seconds.
 
\end_layout

\begin_layout Subsection
Monitoring Progress
\end_layout

\begin_layout Standard
In order to test our hypothesis, we periodically test the performance of
 our GP agents against human coded robots.
 These tests are conducted using the same test architecture, we simply generate
 new battles that pit our GP agents against the robots described below.
 Although fitness values are calculated from these battles, they are not
 used in the selection process.
 Progress checks are performed after the fitness evaluations for every fifth
 generation.
 A total of 12 human-coded robots were used to test progress.
 These robots varied from the very simple to the current one-on-one World
 Champion.
\end_layout

\begin_layout Description
Corners takes a defensive posture in a corner.
 It scans a small arc and fires if it detects the enemy.
\end_layout

\begin_layout Description
Crazy drives randomly over the battlefield hoping to avoid being hit.
 It fires its gun when it detects the enemy.
\end_layout

\begin_layout Description
Fire spins its turret and fires when it detects an enemy.
 It remains stationary until hit, at which time it will move a small distance
 either forward or backward.
\end_layout

\begin_layout Description
RamFire pursues its opponent to ram them.
 Fires when it makes contact with the enemy.
\end_layout

\begin_layout Description
SpinBot drives in a circle and fires when it detects its opponent.
\end_layout

\begin_layout Description
Tracker spins its turret to scan for the opponent.
 When the opponent is detected, it moves towards the other robot by some
 random amount.
 It fires when the opponent remains in its firing arc for several clock
 ticks.
\end_layout

\begin_layout Description
TrackFire implements a simple target tracking gun.
 Remains stationary and fires at a high rate.
\end_layout

\begin_layout Description
Walls dashes to a wall and begins to drive around the perimeter of the battlefie
ld.
 It keeps its gun fixed pointing into the battlefield and fires when it
 detects its opponent.
\end_layout

\begin_layout Description
Splinter is the current World Champion for the Nano-bot class.
 
\end_layout

\begin_layout Description
RaikoMicro is the current World Champion for the Micro-bot class.
\end_layout

\begin_layout Description
Komarious is the current Workd Champion for the Mini-bot class.
\end_layout

\begin_layout Description
Dookious is the current World Champion for one-on-one combat in the unlimited
 class.
\end_layout

\begin_layout Section
\begin_inset LatexCommand \label{sec:Results}

\end_inset

Results
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename fitness_1.pdf
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Caption
Minimum, maximum and average fitness over 1200 generations
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename fitness_2.pdf
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Caption
Minimum, maximum and average fitness over 600 generations after parameter
 modifications
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename progress_2.pdf
	scale 50

\end_inset


\end_layout

\begin_layout Caption
Progress of the agents against the human-coded bots.
 Both the maximum number of bot types beaten and total percentage of agents
 winning against a human coded bot are shown.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The primary result we intend to report is the performance of our evolved
 agents against some set of human-coded Robocode agents.
 We will evaluate our agents periodically and report their progress (whether
 positive or negative) as a function of generation count.
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Standard
Although this experiment was not immediately successful, it does point the
 way towards many interesting future investigations.
 
\end_layout

\begin_layout Enumerate
Continue experimenting with the exogenous fitness function, the node set,
 population size, and the reproduction parameters to attempt to succeed
 with the coevolutionary approach.
 
\end_layout

\begin_layout Enumerate
Experiment with multiple population structures.
\end_layout

\begin_layout Enumerate
Incorporate the results from the progress measurement rounds into the selection
 process.
\end_layout

\begin_layout Enumerate
Modify the driver program to limit the size of the trees.
 This will should reduce execution times and code bloat.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
We must regretfully admit that we did not prove our hypothesis.
 We were not able to evolve competitive Robocode tanks through coevolution
 using an exogenous fitness function.
 That said, this experiment did not show the hypothesis false.
 It is not apparent that coevolution of Robocode tanks cannot succeed.
 We simply have not found a way to cause it to happen.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \bibtex[plain]{refs}

\end_inset


\end_layout

\end_body
\end_document
