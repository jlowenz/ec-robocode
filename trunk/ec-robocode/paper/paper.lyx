#LyX 1.4.3 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{footmisc}
\usepackage{float}
\author{Ronald Bowers \& Jason Owens}
\title{Coevolution of Human-Competitive Robocode Tanks Using Genetic Programming with Exogenous Fitness}
\end_preamble
\language english
\inputencoding auto
\fontscheme ae
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 2
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes true
\end_header

\begin_body

\begin_layout Title
Coevolution of Human-Competitive Robocode Tanks Using Genetic Programming
 with Exogenous Fitness
\end_layout

\begin_layout Author
Ronald Bowers & Jason Owens
\end_layout

\begin_layout Date
4 December, 2006
\end_layout

\begin_layout Abstract
In this paper we attempt to evolve software agents that are capable of competing
 successfully against human-coded agents in Robocode battles.
 We use coevolution and genetic programming along with a custom exogenous
 fitness function to perform the experiment.
 An exogenous fitness function is used since previous research into coevolution
 of Robocode agents using only the endogenous function resulted in mediocre
 stable states.
 Although we continue to perform our investigations, we have yet to achieve
 our stated goal.
 The agents are evolving quite successfully with respect to fitness, do
 not seem to have converged, but still do not compete effectively with even
 the simplest human coded agent.
 
\end_layout

\begin_layout Section
Introduction 
\end_layout

\begin_layout Standard
One of the most intriguing ideas in AI is that of learning through self-play.
 Self-play, or 
\begin_inset Quotes eld
\end_inset

introspection
\begin_inset Quotes erd
\end_inset

 is the idea that a machine learning program can come to master some domain
 by repeatedly competing against itself and gradually improving 
\begin_inset LatexCommand \cite{pollack97coevolution}

\end_inset

.
 Most efforts have been unsuccessful, however some, most notably Tesauro's
 TD-Gammon 
\begin_inset LatexCommand \cite{Tesauro:1995vn}

\end_inset

, have greatly succeeded.
 The essential problem with self-play has been that the programs that develop
 tend to be brittle; they cannot compete when then opposition is changed.
\end_layout

\begin_layout Standard
Within the evolutionary computation paradigm, the coevolutionary approach
 provides a means to develop successful programs through self-play, or more
 precisely, through play against other individuals who are also trying to
 improve.
 Traditional self-play can be likened to the old man in the park playing
 both sides of a chess board.
 A coevolutionary approach is more like a chess club in which all start
 as novices and through competition with each other gradually learn to become
 masters.
\end_layout

\begin_layout Standard
There is disagreement in the literature as to the definition of coevolution
 in the context of evolutionary computation.
 In a biological sense, coevolution means two separate species evolving
 together, e.g.
 flowers and bees.
 Many in the EC community hold to the multiple-population concept 
\begin_inset LatexCommand \cite{Floreano:1999dq,koza1991eac}

\end_inset

, and refer to a self-competing population as a competitive fitness environment
 
\begin_inset LatexCommand \cite{angeline93competitive}

\end_inset

.
 Others in the field insist that it is valid to refer to a self-competing
 single population as coevolutionary since each individual is evolving against
 another evolving population, where the other population is the set of all
 other members 
\begin_inset LatexCommand \cite{Luke:2002fk}

\end_inset

.
 Following Luke, we have chosen to use the term coevolution even if only
 one population is involved.
\end_layout

\begin_layout Standard
Coevolution provides the advantage of a non-static fitness landscape: it
 evolves along with the population because the members are competing against
 each other.
 A goal in coevolutionary systems is for the members to evolve in a such
 a way that an 
\begin_inset Quotes eld
\end_inset

arms race
\begin_inset Quotes erd
\end_inset

 develops.
 An arms race is when the opposing members of the population simultaneously
 begin to develop ways to counter their opposition's strengths and exploit
 their vulnerabilities, which ultimately leads to more rapid evolution of
 the system as a whole.
 
\begin_inset Note Note
status open

\begin_layout Standard
do we have references for this?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Although coevolution appears to be a useful way of evolving game-playing
 agents, historically it has not often been successful in games where there
 is a cost or risk in taking action.
 In this situation, a phenomenon called 
\begin_inset Quotes eld
\end_inset

mediocre stable state
\begin_inset Foot
status collapsed

\begin_layout Standard
The "mediocre stable state" is a state where the population consists of
 members who do absolutely nothing.
 This phenomenon occurs because every action away from the initial condition
 incurs a cost.
 Thus, the starting state it is a local optima for all contestants.
\end_layout

\end_inset

" can occur 
\begin_inset LatexCommand \cite{ficici98challenges,waters1999gpa,Shichel:2005eu}

\end_inset

.
 The mediocre stable state has consistently hindered the use of coevolution
 in the development of combat game playing agents.
 One approach to avoiding the mediocre stable state is through the use of
 an appropriate exogenous fitness function
\begin_inset LatexCommand \cite{waters1999gpa}

\end_inset

.
 
\end_layout

\begin_layout Standard
An interesting
\begin_inset Foot
status collapsed

\begin_layout Standard
At least it's interesting from our point of view: evolving autonomous robotic
 agents on a simulated battlefield seems to be at least partially applicable
 to our current positions at the Army Research Lab.
\end_layout

\end_inset

 environment in which to test the efficacy of coevolution is Robocode.
 Robocode is a robot battle simulation game.
 From the SourceForge project page: 
\end_layout

\begin_layout Quote
Robocode is a Java based programming game, where the goal is to develop
 robot battle tanks to battle against competitor tanks.
 The motto of Robocode is: Build the best, destroy the rest!
\end_layout

\begin_layout Standard
Robocode allows a two or more robots to compete, and a score is computed
 to rank the contestants.
 The details of the scoring and its usefulness in coevolution will be discussed
 in 
\begin_inset LatexCommand \ref{sec:Robocode}

\end_inset

.
 
\end_layout

\begin_layout Standard
The problem we are investigating is whether or not one can use coevolution
 to develop agents that can compete successfully against human-coded agents
 in a Robocode battle.
 One aspect of this problem is how we can avoid producing a mediocre stable
 state; a failure in that respect will result in non-competitive robots.
 We had hypothesized that by using genetic programming and coevolution with
 an exogenous fitness function (to motivate the robots to avoid the mediocre
 stable state), we 
\emph on
could
\emph default
 evolve Robocode players that compete successfully against human-designed
 robots.
 Unfortunately, that goal appears harder to achieve than we thought it would
 be.
\end_layout

\begin_layout Section
\begin_inset LatexCommand \label{sec:Robocode}

\end_inset

Robocode
\end_layout

\begin_layout Standard
As stated previously, Robocode is a programming game.
 It provides a framework in which two or more software agents representing
 robotic tanks (usually hand-coded by a programmer), can fight to the death.
 An objective fitness score is provided in order to rank tanks in a match.
 Moving, shooting, colliding with walls & tanks, and getting shot by an
 enemy cost energy.
 Successfully shooting an enemy returns some energy.
 A typical Robocode match consists of ten combat scenarios with the contestants
 starting in random orientations.
 The Robocode distribution comes with a set of relatively simple bots, with
 advanced bots available online.
 There is also a tournament system that allows developers to compete against
 other bots that have been submitted.
\end_layout

\begin_layout Standard
Eisenstein describes the Robocode environment as a mixture of realism and
 fantasy 
\begin_inset LatexCommand \cite{Eisenstein:2003wd}

\end_inset

: it's a simulation, so there are complex time-dependent relationships between
 actions and effects, but it's also a relatively 
\emph on
simple
\emph default
 simulation with 
\begin_inset Quotes eld
\end_inset

advanced
\begin_inset Quotes erd
\end_inset

 sensors, no noise, and a flat, finite, two dimensional world surrounded
 by walls.
\end_layout

\begin_layout Standard
Each bot executes in its own thread and is event driven.
 The Robocode system synchronizes bot actions and sends messages to a bot
 when various events occur.
 These events include:
\end_layout

\begin_layout Description
ScannedRobot detecting an enemy tank
\end_layout

\begin_layout Description
HitByBullet getting hit by a bullet
\end_layout

\begin_layout Description
WallCollision running into a wall 
\end_layout

\begin_layout Description
RobotCollision running into another robot 
\end_layout

\begin_layout Description
BulletHit hitting another bot with your bullet 
\end_layout

\begin_layout Description
BulletMiss missing any bot with your bullet
\end_layout

\begin_layout Standard
A bot responds to an event with some combination of logic and action execution.
 Any actions are enqueued and subsequently take some time to execute.
 If another event occurs before the first set of actions is completed, the
 actions inspired by the second event are layered on top of the previous
 set and they execute together.
 This interaction between actions, events and the executed response of the
 bot makes designing Robocode bots by hand difficult.
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Subsection
Coevolution
\end_layout

\begin_layout Standard
There has been considerable study of coevolution in evolutionary computation.
 The efforts include research into both multiple population and single populatio
n coevolution.
 
\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand \cite{angeline93competitive}

\end_inset

, Angeline and Pollock argue that competitive fitness functions are more
 effective than independent fitness functions.
 A competitive fitness function is considered to be any calculation of fitness
 that is dependent on the current state of the population, rather than relative
 to a global optimum.
 Generally, competitive fitness is measured through competition between
 population members.
 These competitions can range from testing each member against each other
 to a carefully structured tournament 
\begin_inset LatexCommand \cite{angeline93competitive}

\end_inset

.
 
\end_layout

\begin_layout Standard
Floreano, Nolfi and Mondada 
\begin_inset LatexCommand \cite{Floreano:1999dq}

\end_inset

 found that competitive coevolution can generate efficient chasing and escaping
 strategies in a predator/prey environment.
 They also found that this capability evolved even more quickly than "simple"
 wall avoidance They postulate that competitive coevolution generates solutions
 to difficult problems by generating a series of challenges of increasing
 difficulty.
\end_layout

\begin_layout Standard
Uchibe and Asasa 
\begin_inset LatexCommand \cite{Uchibe:2006qe}

\end_inset

 were able to use coevolution to evolve both competitive and cooperative
 behaviors in soccer playing bots.
\end_layout

\begin_layout Standard
Unfortunately, there are several potential drawbacks to a coevolutionary
 approach.
 The most frequently cited drawback is the learned phenomenon called a 
\begin_inset Quotes eld
\end_inset

mediocre stable state.
\begin_inset Quotes erd
\end_inset

 Ficici and Pollack 
\begin_inset LatexCommand \cite{ficici98challenges}

\end_inset

 found that other difficulties include the need to maintain balance in the
 arms race.
 If the arms race becomes imbalanced, one challenger will be unable to offer
 continued opposition.
 This will slow down or halt the evolution.
 Another issue is that the environment should neither be too easy nor too
 difficult: if the environment is too easy, the population members will
 not be stressed enough to improve; on the other hand, if the environment
 is too hard members will be too stressed; this can lead to low fitness
 and make it difficult to progress.
 They concluded that open-ended coevolution is not necessarily synonymous
 with a purely competitive framework.
 Instead, it's necessary to provide a mixture of competitive and cooperative
 pressures in order to avoid the mediocre stable state.
\end_layout

\begin_layout Standard
Some research has indicated promising techniques that might help to guide
 the coevolutionary process and thus avoid some of the previously-mentioned
 problems.
 De Jong and Pollack 
\begin_inset LatexCommand \cite{dejong2004iec}

\end_inset

 investigated fitness evaluation in coevolutionary systems.
 They found that a problem might consist of multiple competing objectives.
 They also found that it was possible to determine the complete evaluation
 set.
 This set can be used as a 
\begin_inset Quotes eld
\end_inset

perfect teacher
\begin_inset Quotes erd
\end_inset

 that can determine whether one member is dominated by another.
 
\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand \cite{waters1999gpa}

\end_inset

, an exogenous fitness function was proposed.
 Whereas an endogenous fitness function is one provided by the environment
 itself, in their case the programming game AI Wars, an exogenous fitness
 function is one that is specified by the investigators (an example of inductive
 bias) in an effort to guide the evolutionary process.
 Their exogenous fitness function looked for certain specific acts performed
 by the agent.
 The base endogenous score was then modified: positively for good acts,
 negatively for bad acts.
 By using this exogenous fitness function they were able to induce the aggressiv
e behavior that they desired.
\end_layout

\begin_layout Subsection
Genetic Programming
\end_layout

\begin_layout Standard
Genetic programming has been successfully used to develop software agents.
 In 
\begin_inset LatexCommand \cite{Koza:1992bh}

\end_inset

, Koza and Rice describe the development of a robot that could move a box
 around a room by pushing it.
 Their efforts were successful, as the robot eventual grew to be able to
 move the box, and account for issues such as rotation of the box due to
 an off-axis bump.
\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand \cite{montana93strongly}

\end_inset

, Montana develops a strongly-typed genetic programming (STGP) system.
 While still tree-base, his system differs from the Koza's standard approach
 in two primary aspects.
 First, the representation includes specified types for each variable and
 constant as well as the parameters and return value for all functions.
 This change in representation was used to ensure that all generated trees
 had no type-mismatch errors.
 Second, the initial population cannot be generated completely randomly;
 rather, it had to adhere to the typing rules.
 
\end_layout

\begin_layout Standard
Some research has been performed using genetic programming systems that
 were not tree-based.
 These efforts include 
\begin_inset LatexCommand \cite{Eisenstein:2003wd}

\end_inset

, 
\begin_inset LatexCommand \cite{waters1999gpa}

\end_inset

 and 
\begin_inset LatexCommand \cite{lucas:ero}

\end_inset

.
 In 
\begin_inset LatexCommand \cite{Eisenstein:2003wd}

\end_inset

, Eisenstein evolves agents for Robocode using his own custom-designed TableRex
 language based on Leslie Kaelbling's REX language.
 In 
\begin_inset LatexCommand \cite{waters1999gpa}

\end_inset

, Waters and Sheppard experimented in the AI Wars game environment.
 AI Wars bugs are controlled by blocks of procedural code.
 They used five mutation operators and a crossover operator to modify the
 code blocks.
 Finally, in 
\begin_inset LatexCommand \cite{lucas:ero}

\end_inset

, Lucas begins the investigation of how one can use the plethora of existing
 object-oriented class libraries in GP solutions.
 He proposes to use reflection to allow GP programs to discover and use
 existing software.
 This work is in its earliest stages.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
\begin_inset LatexCommand \label{sub:Robocode-based-Investigations}

\end_inset

Robocode-based Investigations
\end_layout

\begin_layout Standard
There have been several projects which have attempted to evolve Robocode
 combatants.
 
\begin_inset LatexCommand \cite{Eisenstein:2003wd,Hong:2004rr,Shichel:2005eu}

\end_inset

.
 Each of these efforts have used a different control architecture, and none
 has successfully used coevolution.
\end_layout

\begin_layout Standard
Eisenstein 
\begin_inset LatexCommand \cite{Eisenstein:2003wd}

\end_inset

 built his Robocode tank using a subsumption architecture that was evolved
 using a GA.
 Coevolution was attempted, but failed to produce any progress towards competiti
ve bots.
 Indeed, he says 
\begin_inset Quotes eld
\end_inset

after several generations, I found the population rife with catatonics.
\begin_inset Quotes erd
\end_inset

 The experiment proceeded using the standard Robocode bots plus one high-perform
ance bot as the opposition.
 Eisenstein also explicitly points out that targeting behaviors were very
 hard to evolve.
 
\end_layout

\begin_layout Standard
The bots were evolved in four, increasingly complex, environments.
\end_layout

\begin_layout Itemize
Single adversary, single starting position
\end_layout

\begin_layout Itemize
Single adversary, multiple starting positions
\end_layout

\begin_layout Itemize
Multiple adversaries
\begin_inset Foot
status collapsed

\begin_layout Standard
Multiple adversaries means that a combination of pre-defined tanks were
 fought.
 Combat was still one-on-one.
\end_layout

\end_inset

, single starting position
\end_layout

\begin_layout Itemize
Multiple adversaries, multiple starting positions
\end_layout

\begin_layout Standard
For the single adversary, single starting position case, bots that could
 reliably defeat their opposition evolved quickly.
 However, as the complexity of the environment increased, success became
 less common.
 Hindering the process was the fact that the more complex simulations took
 much longer to run.
\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand \cite{Hong:2004rr}

\end_inset

, Hong and Cho used a GA that consisted of six chromosomes, each of which
 had six genes.
 The chromosomes were related to the behavior the tank would exhibit in
 the main loop and in five of the event handlers.
 Each gene corresponded to a specific action-type of the tank, for example
 
\emph on
\noun on
move
\emph default
\noun default
 and 
\emph on
\noun on
shoot
\emph default
\noun default
.
 For each action, two or more hand-coded strategies were developed.
 They were able to evolve tanks that could compete successfully against
 three of the basic tanks, but they had little success in defeating a more
 advanced tank.
\end_layout

\begin_layout Standard
A third experiment was performed by Shichel, Ziserman, and Sipper
\begin_inset LatexCommand \cite{Shichel:2005eu}

\end_inset

.They chose to limit their investigation to a particular class of Robocode
 bot, the 
\noun on
Haiku bot
\noun default
.
 The Haiku bot is limited to four lines of custom code, where the number
 of lines is indicated by the number of semicolons.
 After investigating and rejecting Strongly Typed Genetic Programming and
 Automatically Defined Functions, they chose a Koza-style LISP implementation.
 This had the extra benefit of allowing complex expressions since the the
 Haiku bot class places no limit on the number of parentheses (and thus
 the size of the expression).
 After completing the evolution process, the highest performing bot was
 entered into the Robocode Haiku Bot tournament.
 Remarkably, it finished third out of 27 contestants, where all other contestant
s were hand-coded.
 
\end_layout

\begin_layout Standard
Shichel, Ziserman, and Sipper also investigated coevolution, but found that
 the coevolved bots showed primitive behavior and were easily defeated by
 human-coded bots.
 To overcome the mediocre steady state that arose rapidly in Eisenstein's
 work, they propose in future work to bootstrap the evolutionary process
 with competition against human-coded bots.
 After a few generations in this configuration, they would switch to a coevoluti
onary approach.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Approach
\end_layout

\begin_layout Standard
Ignoring the failures of others, we plan to carry through and explore the
 experiment using genetic programming and coevolution in this rather 
\begin_inset Quotes eld
\end_inset

open-ended
\begin_inset Quotes erd
\end_inset

 domain.
 As mentioned in Section\InsetSpace ~

\begin_inset LatexCommand \ref{sub:Robocode-based-Investigations}

\end_inset

, previous research in evolving Robocode agents reported failure when pursuing
 a coevolutionary model, and thus they resorted to training against known
 quantities 
\begin_inset LatexCommand \cite{Eisenstein:2003wd,Shichel:2005eu}

\end_inset

.
 However, in doing this, the danger of evolving specialized players unable
 to handle generalized situations (i.e.
 new players with different tactics) is increased; in fact, 
\begin_inset LatexCommand \cite{Shichel:2005eu}

\end_inset

 mentions observing this exact problem.
 From our point of view, coevolution is obviously more exciting; we believe
 that the lack of an appropriate exogenous fitness function is the primary
 reason the previous ventures failed during coevolution.
 As 
\begin_inset LatexCommand \cite{ficici98challenges}

\end_inset

 states: 
\begin_inset Quotes eld
\end_inset

[t]he key to successful coevolutionary learning is a competitive arms race
 between opposed participants.
 Competitors must be well-matched in skill to force each other to improve.
\begin_inset Quotes erd
\end_inset

 We would like to add that competitors must also be sufficiently 
\emph on
motivated
\emph default
 in order to avoid the mediocre stable-states common to coevolution 
\begin_inset LatexCommand \cite{angeline93competitive,ficici98challenges,waters1999gpa}

\end_inset

.
\end_layout

\begin_layout Standard
The following subsections describe the high-level aspects of our experiment,
 including the representation, operators, evaluation, algorithm configuration,
 and the execution environment.
\end_layout

\begin_layout Subsection
Representation
\end_layout

\begin_layout Standard
The genome for an individual in the population consists of a forest of expressio
n trees.
 Using our knowledge of the Robocode domain, we identified four primary
 tasks for the bot: manage movement, manage the radar, manage turret/targeting,
 and manage firing; thus, we require four separate controllers.
 To reduce the complexity of the problem somewhat, we assume that the "robotic
 platform" we are "executing" on accepts the following input from our controller
s: a vector indicating movement, an angle relative to the heading for the
 radar direction, an angle relative to the heading for the turret direction,
 and a boolean/energy pair indicating whether to fire and how much energy
 the bullet should have.
 We believed this assumption would allow the algorithm to converge more
 quickly since it constrains the hyperspace of possible solutions; however,
 it may put an upper bound on the performance of the evolved agents; a deficienc
y that could hinder an agent's capability to beat a human-coded bot.
\begin_inset Note Note
status collapsed

\begin_layout Standard
diagram of robotic platform and inputs to existing controller from GP forest
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each executable tree is recursively constructed of functions (or non-terminals,
 as we prefer) of various arity, and terminals with 0 arity.
 The nodes (both terminals and non-terminals) are strongly typed, after
 an adaptation of strongly-typed genetic programming described in 
\begin_inset LatexCommand \cite{montana93strongly}

\end_inset

.
 Only nodes that return the correct type can be used as a parameter to a
 non-terminal accepting a specific type.
 This complicates the genetic operators somewhat and will be discussed in
 section\InsetSpace ~

\begin_inset LatexCommand \ref{sub:Operators}

\end_inset

.
 
\end_layout

\begin_layout Standard
Tables 
\begin_inset LatexCommand \ref{tab:Sensor-terminals}

\end_inset

--
\begin_inset LatexCommand \ref{tab:Non-terminals}

\end_inset

 list the domain specific nodes for each event tree.
 Symbols present in the tables indicate the argument types and return types:
 
\begin_inset Formula $\theta$
\end_inset

 is an angle in radians, 
\begin_inset Formula $\delta$
\end_inset

 is a distance, 
\begin_inset Formula $\lambda$
\end_inset

 is an abstract level, 
\begin_inset Formula $\epsilon$
\end_inset

 is an energy level, 
\begin_inset Formula $\beta$
\end_inset

 is a boolean value, 
\begin_inset Formula $\vec{v}$
\end_inset

 is a two-dimensional vector, and 
\begin_inset Formula $\tau$
\end_inset

 is a generic type.
 
\end_layout

\begin_layout Standard
In addition to the domain-specific nodes, there are a few 
\begin_inset Quotes eld
\end_inset

standards
\begin_inset Quotes erd
\end_inset

 that we include as well, described in Table\InsetSpace ~

\begin_inset LatexCommand \ref{tab:Standard-non-terminals}

\end_inset

.
 All of the generic arithmetic nodes can operate on any pair of scalar numeric
 types (i.e.
 angle, distance, energy level).
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Standard
Update these tables! Missing some nodes
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Syntax
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Returns
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
add 
\begin_inset Formula $\tau$
\end_inset

 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
sub 
\begin_inset Formula $\tau$
\end_inset

 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
mult 
\begin_inset Formula $\tau$
\end_inset

 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
div 
\begin_inset Formula $\tau$
\end_inset

 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\tau<\tau$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\tau>\tau$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta\wedge\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta\vee\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\neg\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
if-then-else 
\begin_inset Formula $\beta$
\end_inset

 
\begin_inset Formula $\tau$
\end_inset

 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
First if 
\begin_inset Formula $\beta=T$
\end_inset

 else second
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
constant_boolean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
constant 
\begin_inset Formula $\beta$
\end_inset

 value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
constant
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
constant 
\begin_inset Formula $\lambda$
\end_inset

 value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
contant_vector
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
constant 
\begin_inset Formula $\vec{v}$
\end_inset

 value
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{tab:Standard-non-terminals}

\end_inset

Standard nodes
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="24" columns="3">
<features>
<column alignment="left" valignment="top" width="30line%">
<column alignment="center" valignment="top" leftline="true" width="10line%">
<column alignment="left" valignment="top" leftline="true" width="50line%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Syntax
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Returns
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
isMoving
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Is the bot moving?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
currentVector
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Where is the bot is currently going?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
isTurretMoving
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Is the bot's turret moving?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
currentTurretHeading
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Where is the turret currently pointing?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
isRadarMoving
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Is the bot's radar moving?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
currentRadarHeading
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Where is the radar currently pointing?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
energyLevel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\epsilon$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
The bot's current energy level.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
gunHeat
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\lambda$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
The gun's heat (can't fire unless 
\begin_inset Formula $\lambda=0$
\end_inset

 ).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
vectorToForwardWall
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
The vector to the wall directly in front of the bot.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
vectorToNearestWall
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
The vector to the nearest wall, relative to the bot's heading.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
recentlyHitWall
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Did the bot hit the wall since the last time this sensor was read?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
recentlyHitByBullet
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Was the bot hit by a bullet since the last time this sensor was read?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
recentlyRammed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Was the bot rammed since the last time this sensor was read?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
myFault
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\beta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Was the ramming my fault?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
bulletBearing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Where did the bullet come from (relative to bot heading when hit).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
bulletEnergy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\epsilon$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
How much energy did the bullet have?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
bulletSpeed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\omega$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
How fast are bullets?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
rammerBearing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Where did the ramming bot come from (relative to bot heading when hit).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
lastVectorToEnemy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Vector to the last known location of the enemy.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
lastHeadingOfEnemy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
The last known direction the enemy was heading.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
lastSpeedOfEnemy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\omega$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
The last known speed of the enemy.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
hitByBulletAge
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\lambda$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Time since last bullet hit.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
hitWallAge
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\lambda$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Time since last wall hit.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{tab:Sensor-terminals}

\end_inset

Sensor terminals
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features>
<column alignment="left" valignment="top" rightline="true" width="30line%">
<column alignment="center" valignment="top" rightline="true" width="10line%">
<column alignment="left" valignment="top" width="50line%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Syntax
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Returns
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
toVector 
\begin_inset Formula $\theta$
\end_inset

 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Calculates the vector that represents the given heading and distance relative
 to the robot's current heading.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
rotateVector 
\begin_inset Formula $\vec{v}$
\end_inset

 
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Calculates a new vector by rotating it the given amount.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
scaleVector 
\begin_inset Formula $\vec{v}$
\end_inset

 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Calculates a new vector by scaling it the given amount.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
vectorLength 
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Calculates the length of the vector.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
vectorHeading 
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Calculates the heading of the vector relative to the robot's heading.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
dotProduct 
\begin_inset Formula $\vec{v}$
\end_inset

 
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Calculates the do product of two vectors.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
negateVector 
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Reverses the given vector
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
vectorFromHeading 
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\vec{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Calculates the unit vector from the given heading
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{tab:Non-terminals}

\end_inset

Non-terminals
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset LatexCommand \label{sub:Operators}

\end_inset

Operators
\end_layout

\begin_layout Standard
We use two reproductive operators: crossover and mutation.
 As noted earlier, the standard GP versions of these operators will not
 work in our case, since any given node may not be compatible with any other
 node due to a type mismatch.
 Therefore, both operators are modified to explicitly support the strong
 typing.
 In addition, the operators will only operate between like chromosomes (e.g.
 the movement tree).
\end_layout

\begin_layout Subsubsection
Crossover
\end_layout

\begin_layout Standard
The crossover operator takes 2 parent trees and produces 2 offspring created
 by swapping randomly chosen subtrees between parents.
 As described in 
\begin_inset LatexCommand \cite{montana93strongly}

\end_inset

, a random node is picked from tree A to serve as the root of the swapped
 subtree 
\begin_inset Formula $\alpha$
\end_inset

.
 Now a subtree must picked from tree B.
 However, due to the requirement of matching the parent type of subtree
 
\begin_inset Formula $\alpha$
\end_inset

, subtree 
\begin_inset Formula $\beta$
\end_inset

 cannot be chosen from any node.
 It must be randomly chosen from the set of nodes having the appropriate
 type.
 If 1 or more matching nodes exist, one is chosen randomly as the root of
 subtree 
\begin_inset Formula $\beta$
\end_inset

, otherwise the operator returns the parents or nothing.
\end_layout

\begin_layout Subsubsection
Mutation
\end_layout

\begin_layout Standard
Even though mutation is typically omitted from a GP with the claim that
 it adds little utility 
\begin_inset LatexCommand \cite{Sheppard:2006fk}

\end_inset

, we choose to include it for several reasons.
 We like the idea that mutation helps us explore the entire search space
 (which crossover just can't do), and since we will probably be using a
 relatively small population size due to time constraints and minimal computatio
nal resources, mutation will help since it's unlikely that all valid operations
 will exist in the initial population.
 For example, consider an operator that takes a value, such as (add 
\begin_inset Formula $\alpha$
\end_inset

 
\begin_inset Formula $\beta$
\end_inset

).
 The amount to add is specified as an argument.
 Crossover and reproduction cannot explore how much to add unless all parameter
 values are represented in the initial population.
 It is more practical to allow mutation of such parameters.
 
\end_layout

\begin_layout Standard
The mutation operator itself consists of all four primary variations 
\begin_inset LatexCommand \cite{Sheppard:2006fk}

\end_inset

 (grow, shrink, cycle and switch) as well as a custom variation to operate
 on the constant numerical values that can be present in our trees.
 As was the case with crossover, the 4 tree variations must be modified
 to handle the strong typing constraints.
 For example, the cycle variation may only choose from nodes that match
 what the existing parent node expects.
 Since the custom variation only deals with numerical constants, it 
\begin_inset Quotes eld
\end_inset

automatically
\begin_inset Quotes erd
\end_inset

 handles the typing constraints.
\end_layout

\begin_layout Standard
The custom variation is based on real-valued mutation, where the general
 form is 
\begin_inset Formula $x'=x+m$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

 is a random value such that 
\begin_inset Formula $m\sim U(a,b)$
\end_inset

 where 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 are lower and upper bounds 
\begin_inset LatexCommand \cite{Sheppard:2006fk}

\end_inset

, configurable per type.
\end_layout

\begin_layout Subsection
Evaluation and Fitness Functions
\end_layout

\begin_layout Standard
Our implementation of coevolution follows that of the model described in
 
\begin_inset LatexCommand \cite{Luke:2002fk}

\end_inset

: one-population coevolution, where single individuals compete with every
 other individual to obtain an overall fitness value.
 Thus, the evaluation of fitness for each individual will be calculated
 by matching that individual against all other individuals in the population,
 including itself (we see no reason to exclude this self-play from the evaluatio
n stage) where the resulting fitness value will be calculated as the average
 fitness over all matches.
 A match consists of a set of 10 two player tank-to-tank combat scenarios,
 with random starting orientations selected for each scenario.
 The match score will be the median fitness value from the sequence of combat
 scenarios.
\end_layout

\begin_layout Standard
As mentioned previously, we believe the failures encountered with previous
 explorations of genetically programmed Robocode agents under coevolution
 occurred due to the use of the natural endogenous fitness function: the
 score provided by Robocode.
 This score is based on various factors including: survival relative to
 other bots, last bot alive bonus, bullet damage to enemies, bullet kill
 bonus, ram damage to enemies, and ram kill bonus 
\begin_inset LatexCommand \cite{Nelson:2006kx}

\end_inset

.
 Note that firing a bullet, getting hit by a bullet, ramming a bot (or getting
 rammed), and colliding with a wall all cause 
\begin_inset Quotes eld
\end_inset

damage
\begin_inset Quotes erd
\end_inset

 in the form of reducing the overall energy level of the robot.
 When the energy level drops to zero, the bot is dead.
 Since bots in a coevolutionary environment start at about the same level
 with very primitive movement, firing, targeting and scanning skills, the
 most productive thing (i.e.
 the one generating the highest relative score) to do is sit still.
 Even though successfully shooting an enemy is rewarded, the primitive skills
 prevent accuracy, and thus simply waste energy.
 The best successful strategy in this situation is to do nothing: a mediocre
 stable state.
 
\end_layout

\begin_layout Subsection
Tuning the Exogenous Fitness Function
\end_layout

\begin_layout Standard
We have developed and tested several exogenous fitness functions in the
 hopes of finding one that guides our GP agents in the desired evolutionary
 direction.
 As was stated previously, we eschewed the endogenous Robocode score because
 it favors energy conservation in general and using it in a coevolutionary
 system can easily lead to mediocre stable states.
 In this section we will describe the functions we tried, the motivation
 for each function, and, for the earlier functions, the observed outcome.
\end_layout

\begin_layout Subsubsection
The First Fitness Function
\end_layout

\begin_layout Standard
Our initial fitness function was based on the idea that the GP agents should
 shoot and not get shot.
 Thus we formulated the simple equation:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
F=W_{d}\cdot b_{dodged}+W_{f}\cdot b_{fired}\]

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $b_{\mathit{fired}}$
\end_inset

 is the count of bullets fired, 
\begin_inset Formula $b_{dodged}$
\end_inset

 is defined in 
\begin_inset LatexCommand \ref{eq:dodged}

\end_inset

, and 
\begin_inset Formula $W_{d}=1$
\end_inset

 and 
\begin_inset Formula $W_{f}=1$
\end_inset


\begin_inset Formula \begin{equation}
b_{dodged}=b_{\mathit{fired\, by\, opponent}}-b_{hit\; by\; opponent}\label{eq:dodged}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
This fitness function was an absolute failure.
 It quickly led to agents that shot wildly, but generally took no other
 action.
 The 
\begin_inset Formula $b_{dodged}$
\end_inset

 term dominated the fitness value because any errant shot gave the opponent
 a point for dodging, even if they did nothing.
 This function was quickly abandoned.
\end_layout

\begin_layout Subsubsection
The Second Fitness Function
\end_layout

\begin_layout Standard
With the second fitness function we attempted to coax our agents to include
 three additional desired behaviors: movement, enemy sensing, and wall avoidance.
 The function was:
\begin_inset Formula \begin{equation}
F=\begin{array}{cc}
W_{f}\cdot b_{fired}+W_{d}\cdot b_{dodged}+\\
W_{h}\cdot h+W_{s}\cdot s+W_{m}\cdot m\end{array}\label{eq:fit2}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $W_{f}=1.5$
\end_inset

, 
\begin_inset Formula $W_{d}=1.0$
\end_inset

, 
\begin_inset Formula $W_{h}=-2.0$
\end_inset

, 
\begin_inset Formula $W_{s}=1.0$
\end_inset

, and 
\begin_inset Formula $W_{m}=0.1$
\end_inset

 are the weights for bullets fired, bullets dodged, walls hit, number of
 enemy scans, and distance travelled (movement) respectively, while the
 new values 
\begin_inset Formula $h$
\end_inset

, 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

 are the number of registered wall hits, scans of the enemy and raw distance
 travelled.
 This fitness did improve upon the first, in that the agents learned to
 keep moving (and move great distances at that), generally avoid walls,
 fire all the time and spin their radars constantly.
 They rapidly converged to this state, and didn't make much progress after
 that.
\end_layout

\begin_layout Subsubsection
The Third Fitness Function
\end_layout

\begin_layout Standard
The third fitness function was the first to take Robocode wins into consideratio
n.
 It also adjusted the distance measurement to better compare values.
 The 
\begin_inset Formula $m$
\end_inset

 term in equation 
\begin_inset LatexCommand \ref{eq:fit2}

\end_inset

 was replaced with:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
m=\frac{d_{robot}}{d_{robot}+d_{opponent}}\]

\end_inset


\end_layout

\begin_layout Standard
a ratio of distance travelled relative to the total distance travelled of
 each agent.
 Thus, the weight was adjusted to 
\begin_inset Formula $W_{m}=100$
\end_inset

.
 The additional wins term took the form: 
\begin_inset Formula $W_{w}\cdot w$
\end_inset

 where 
\begin_inset Formula $w$
\end_inset

 was the number of times the robot won the battle (out of the 10 stochastic
 rounds) and 
\begin_inset Formula $W_{w}=100$
\end_inset

 as well.
 This function also improved somewhat on the previous fitness, since it
 deemphasized the distance and actually took into consideration whether
 a robot beat the opponent.
 However, the agents still converged to suboptimal behavior, which primarily
 took the form of heading toward walls and firing all the time.
\end_layout

\begin_layout Subsubsection
The Final Fitness Function
\end_layout

\begin_layout Standard
Our current exogenous fitness function emphasizes the damage inflicted on
 the opponent.
 The fitness function is:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
F=\frac{wins}{10}\cdot\left(F_{damage}+F_{tweak}\right)+F_{activity}\label{eq:final_fitness}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The term 
\begin_inset Formula $F_{damage}$
\end_inset

is the contribution to fitness from the damage inflicted by the robot.
 It is defined as:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
F_{damage}=\begin{array}{cc}
D_{bullet}+D_{ram}+B_{bullet}+B_{ram}+\\
e_{bullet}D_{bullet}+e_{scan}D_{bullet}\end{array}\]

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $D_{bullet}$
\end_inset

 is the damage inflicted by this robot against its opponent, and 
\begin_inset Formula $D_{ram}$
\end_inset

 is the damage inflicting by ramming the opponent.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
These scores are provided by Robocode.
 The terms 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default

\begin_inset Formula $B_{bullet}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
 and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default

\begin_inset Formula $B_{ram}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
 are bonuses given by Robocode for killing the opponent by bullet or by
 ramming, respectively.
 The bonuses are also provided by Robocode.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
The term 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default

\begin_inset Formula $e_{bullet}$
\end_inset

 is bonus multiplier based on shot accuracy.
 It is defined by: 
\end_layout

\begin_layout Standard
\begin_inset Formula \[
e_{bullet}=5\cdot\frac{Hits}{Bullets\: Fired}\]

\end_inset


\end_layout

\begin_layout Standard
The intent of the bullet efficiency term is to overcome the tendency to
 shoot wildly that was seen when using the first fitness function.
 Similarly, 
\begin_inset Formula $e_{scan}$
\end_inset

is a multiplier for scan efficiency.
 Scan efficiency expresses the number of 
\begin_inset Quotes eld
\end_inset

Enemy Scanned
\begin_inset Quotes erd
\end_inset

 events as a function of the angular distance the radar turns.
 The purpose of this term is to overcome the tendency to simply spin the
 radar and to keep the radar pointed towards the enemy instead.
 Scan efficiency is defined by:
\begin_inset Formula \[
revs=\frac{Total\: Radians\: Turned}{2\pi}\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
e_{scan}=\frac{Scan\; Events-revs}{4\cdot revs}\]

\end_inset


\end_layout

\begin_layout Standard
To compute the efficiency metrics and 
\begin_inset Formula $F_{tweak}$
\end_inset

, Robocode was modified to record the number of shots, the number of hits,
 the radians the radar turns, the number of scan events, and the total distance
 travelled.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $F_{tweak}$
\end_inset

 term is intended to give the agent some credit for moving, shooting, and
 scanning.
 The use of logarithms slows the growth of 
\begin_inset Formula $F_{tweek}$
\end_inset

 and prevents it from overwhelming the 
\begin_inset Formula $F_{damage}$
\end_inset

 score.
 It is defined as:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
F_{tweak}=\begin{array}{cc}
\ln\left(Shots\; Fired\right)\\
+\ln\left(Scan\; Events\right)\\
+\ln\left(Distance\; Traveled\right)\end{array}\]

\end_inset


\end_layout

\begin_layout Standard
Since the 
\begin_inset Formula $F_{damage}$
\end_inset

 and 
\begin_inset Formula $F_{tweak}$
\end_inset

 scores are scaled by the winning percentage, and wins is a Robocode-provided
 metric, it is possible for an agent that has a good
\begin_inset Formula $F_{damage}$
\end_inset

 and 
\begin_inset Formula $F_{tweak}$
\end_inset

 to have its fitness zeroed by losses.
 To avoid this, a small bonus, 
\begin_inset Formula $F_{activity}$
\end_inset

, is added to a bot that moves, shoots, or scans during the battle.
 The value of 
\begin_inset Formula $F_{activity}$
\end_inset

 is a constant 5.0
\end_layout

\begin_layout Subsection
GP Algorithm Configuration
\end_layout

\begin_layout Subsubsection
Initial Tree Creation
\end_layout

\begin_layout Standard
We generate tree's using Koza's 
\emph on
ramped half-and-half
\emph default
 method (described in 
\begin_inset LatexCommand \cite{Luke:2001kx}

\end_inset

), which is apparently the de facto standard for tree initialization.
 This method generates trees by randomly choosing a depth from a pre-configured
 depth range, then probabilistically choosing either the GROW or FULL generation
 method.
 The GROW algorithm is essentially the same as the grow mutation variation,
 randomly choosing non-terminals and terminals to generate a tree up to
 the depth range.
 FULL differs from the GROW algorithm by always choosing non-terminals in
 order to always generate full trees.
 Each tree in our forest-based genome can have it's own set of parameters
 (max/min depth), however we set them all equal.
\end_layout

\begin_layout Subsubsection
Selection and Replacement
\end_layout

\begin_layout Standard
We select individuals using the ranked-order method.
 Replacement is generational, with elitism 
\begin_inset LatexCommand \cite{Sheppard:2006uq}

\end_inset

.
 Specific parameters are shown in Table\InsetSpace ~

\begin_inset LatexCommand \ref{tab:Algorithm-parameters}

\end_inset

.
 As is the case in many evolutionary computation experiments, we have tweaked
 the parameters several times during our investigations.
 The values are shown in Table\InsetSpace ~

\begin_inset LatexCommand \ref{tab:Algorithm-parameters}

\end_inset

.
\end_layout

\begin_layout Subsubsection
Parameters
\end_layout

\begin_layout Standard
Comparison of proposed and used parameters is shown in Table 
\begin_inset LatexCommand \ref{tab:Algorithm-parameters}

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Might want to compare proposed and used.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="4">
<features>
<column alignment="left" valignment="top" rightline="true" width="50col%">
<column alignment="center" valignment="top" width="25col%">
<column alignment="center" valignment="top" leftline="true" width="25col%">
<column alignment="center" valignment="top" leftline="true" width="30col%">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Proposed Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
First Run Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Final Value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Population Size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
24
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
24
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
footnotemark
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Maximum Generations
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Until convergence\SpecialChar \ldots{}

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
600
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Crossover rate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
.8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Mutation rate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.05
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Reproduction rate (direct copy of parents)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Elitism
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Top 10 percent
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Top agent
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Top 2 members
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Maximum initial tree depth
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Maximum tree depth after crossover & mutation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No limit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
No limit
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{tab:Algorithm-parameters}

\end_inset

Algorithm parameters
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
footnotetext{The population size is so small due to the nature of the evaluation
: there will be $
\backslash
frac{n(n-1)}{2}+n$ matches, where a match consists of 10 combat scenarios.
 Thus, the total number of game "runs" per generation will be 50000, and
 if each run takes .5 seconds, it's still 6.9 cpu hours per generation.}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset LatexCommand \label{sub:Execution-Environment}

\end_inset

Execution Environment 
\end_layout

\begin_layout Standard
Given a population size of 24, and allowing for self-play, 300 fitness evaluatio
ns are necessary for each generation.
 If all Robocode battles ran in 5 seconds, which is optimistic, processing
 1024 generations would take 17.36 days.
 In order to perform the large number of fitness evaluations necessary in
 the time available, we implemented an architecture that allows us to distribute
 our fitness evaluations across multiple computers.
\end_layout

\begin_layout Standard
The architecture we have developed (shown in Figure 
\begin_inset LatexCommand \ref{fig:Simple-architecture-illustration}

\end_inset

) is based on a simple master-worker pattern.
 The workers consist of instances of Robocode that have been slightly modified.
 The master is a custom driver program.
 Communication between the master and the workers is conducted through a
 JavaSpace.
 The operation of the architecture is:
\end_layout

\begin_layout Enumerate
The driver program generates the initial population.
\end_layout

\begin_layout Enumerate
The driver program generates a series of tasks that specify a battle to
 be fought.
 One task is generated for each robot pairing.
 The task contains the eight GP trees necessary to define the behavior of
 the two competing robots.
\end_layout

\begin_layout Enumerate
The tasks are submitted to the JavaSpace.
\end_layout

\begin_layout Enumerate
The Robocode workers pull the battle tasks from the space and execute them.
\end_layout

\begin_layout Enumerate
When each battle concludes, the Robocode worker calculates the fitness of
 the two contestants and submits a results object to the space.
\end_layout

\begin_layout Enumerate
The driver program pulls the results from the space.
\end_layout

\begin_layout Enumerate
Selection and reproduction is performed by the driver.
\end_layout

\begin_layout Enumerate
The process repeats with the new population.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename javaspace.pdf
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:Simple-architecture-illustration}

\end_inset

Simple architecture illustration
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Several modification have been made to Robocode in order to integrate it
 with this architecture.
 These changes enable Robocode to read battle tasks from the JavaSpace and
 to put the battle results into the space.
 Additional changes were necessary to collect data for the exogenous fitness
 function.
 Some small performance enhancements also have been made.
 The system configuration for our first run consisted of 15 hosts with a
 total of 59 processors.
 Using this configuration, processing one generation took between 30 and
 90 seconds.
 The number of processors used for the second run was slightly less, and
 the generation times were in excess of two minutes.
\end_layout

\begin_layout Subsection
Monitoring Progress
\end_layout

\begin_layout Standard
In order to test our hypothesis, we periodically test the performance of
 our GP agents against human-coded bots.
 These tests are conducted using the same test architecture, we simply generate
 new battles that pit our GP agents against the bots described below.
 Although fitness values are calculated from these battles, they are not
 used in the selection process.
 Progress checks are performed after the fitness evaluations for every fifth
 generation.
 A total of 12 human-coded 
\begin_inset Quotes eld
\end_inset

progress bots
\begin_inset Quotes erd
\end_inset

 were used to test progress.
 These bots varied from the very simple to the current one-on-one World
 Champion.
\end_layout

\begin_layout Description
Corners takes a defensive posture in a corner.
 It scans a small arc and fires if it detects the enemy.
\end_layout

\begin_layout Description
Crazy drives randomly over the battlefield hoping to avoid being hit.
 It fires its gun when it detects the enemy.
\end_layout

\begin_layout Description
Fire spins its turret and fires when it detects an enemy.
 It remains stationary until hit, at which time it will move a small distance
 either forward or backward.
\end_layout

\begin_layout Description
RamFire pursues its opponent to ram them.
 Fires when it makes contact with the enemy.
\end_layout

\begin_layout Description
SpinBot drives in a circle and fires when it detects its opponent.
\end_layout

\begin_layout Description
Tracker spins its turret to scan for the opponent.
 When the opponent is detected, it moves towards the other robot by some
 random amount.
 It fires when the opponent remains in its firing arc for several clock
 ticks.
\end_layout

\begin_layout Description
TrackFire implements a simple target tracking gun.
 Remains stationary and fires at a high rate.
\end_layout

\begin_layout Description
Walls dashes to a wall and begins to drive around the perimeter of the battlefie
ld.
 It keeps its gun fixed pointing into the battlefield and fires when it
 detects its opponent.
\end_layout

\begin_layout Description
Splinter is the current World Champion for the Nano-bot class.
 
\end_layout

\begin_layout Description
RaikoMicro is the current World Champion for the Micro-bot class.
\end_layout

\begin_layout Description
Komarious is the current Workd Champion for the Mini-bot class.
\end_layout

\begin_layout Description
Dookious is the current World Champion for one-on-one combat in the unlimited
 class.
\end_layout

\begin_layout Section
\begin_inset LatexCommand \label{sec:Results}

\end_inset

Results and Discussion
\end_layout

\begin_layout Subsection
Results
\end_layout

\begin_layout Standard
After some experimentation, we ran two runs using the fitness defined in
 equation\InsetSpace ~

\begin_inset LatexCommand \ref{eq:final_fitness}

\end_inset

.
 The first run covered 1200 generations, the second run covered only 600
 generations (due to time constraints).
 Although the second run was shorter, the fitness values obtained and the
 progress statistics are 
\begin_inset Quotes eld
\end_inset

better
\begin_inset Quotes erd
\end_inset

 in general.
 
\end_layout

\begin_layout Subsubsection
First run
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename fitness_1.pdf
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:fit1}

\end_inset

Minimum, maximum and average fitness over 1200 generations
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure\InsetSpace ~

\begin_inset LatexCommand \ref{fig:fit1}

\end_inset

 illustrates the instantaneous maximum, average, and minimum fitness values
 over the entire first run.
 Note the interesting surge in overall fitness between generations 700--1000.
 Figures 
\begin_inset LatexCommand \ref{fig:scn1}

\end_inset

 and 
\begin_inset LatexCommand \ref{fig:fir1}

\end_inset

, illustrate the scanning efficiency and firing accuracy, both important
 aspects of the fitness, and they also indicate the same surge in capability,
 as one would expect.
 Bullet damage (see Figure 
\begin_inset LatexCommand \ref{fig:bul1}

\end_inset

) didn't show quite the same surge, but it is noticeable between 800--1000.
 The distance travelled (shown in Figure 
\begin_inset LatexCommand \ref{fig:dist1}

\end_inset

) showed the interesting property of converging around 20K pixels.
 This doesn't necessarily make sense, until one actually looks at the behavior
 of the GP agents (which we do below).
\end_layout

\begin_layout Standard
Unfortunately, the most important aspect of the first run is the figure
 that is missing, the progress tests.
 The reason it's missing is that there was nothing interesting to graph!
 Only 8 out of 1200 generations produced an agent that beat 1 human-coded
 bot.
 In other words, the first run was a failure.
 
\end_layout

\begin_layout Standard
In observing the behavior of the agents throughout the last 200 generations
 (done by randomly hand-picking agents and pitting them against a hand-coded
 bot under interactive Robocode), it was apparent that while the fitness
 hadn't exactly converged (although the slight downward trend is not encouraging
), the agents' behaviors were 
\emph on
very
\emph default
 similar to one another, and the behavior was horrible.
 As mentioned above, the fact that the distance metric converged under stochasti
c initial conditions was puzzling.
 However, the observed behavior indicated that the widespread tactic was
 to immediately head for a wall, possibly scan for an opponent, and possibly
 shoot.
 Re-examining the Robocode source indicates that we were recording 
\emph on
desired
\emph default
 positional deltas, not 
\emph on
actual
\emph default
 potential deltas.
 This problem is also present in the second run.
 
\end_layout

\begin_layout Standard
After some thought (and definitely not enough analysis), we postulated that
 this was due to a too-high mutation
\begin_inset Foot
status collapsed

\begin_layout Standard
The reason our initial setting of mutation was so high is that we were concerned
 with the need to use a small population size.
 A small population size may not have enough diversity, and a higher mutation
 rate may help replace that deficiency.
\end_layout

\end_inset

 and crossover rate
\begin_inset Foot
status collapsed

\begin_layout Standard
The crossover rate was also set higher due to the same logic.
\end_layout

\end_inset

, and not enough 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

 genetic material being kept around (i.e.
 too-little elitism).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename scan1.pdf
	scale 50

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:scn1}

\end_inset

Scan Efficiency over 1200 generations
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename firing1.pdf
	scale 50

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:fir1}

\end_inset

Firing Accuracy over 1200 Generations
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename bullet_damage1.pdf
	scale 50

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:bul1}

\end_inset

Bullet damage over 1200 Generations
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename dist_travelled1.pdf
	scale 50

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:dist1}

\end_inset

Distance travelled over 1200 Generations
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Second Run
\end_layout

\begin_layout Standard
The failure of the first run prompted us to modify the algorithm parameters
 to reduce the mutation significantly (closer to others' research parameters),
 and slightly reduce the crossover rate.
 We also reduced the initial tree depth, since we had experimented with
 manually constructing very 
\emph on
simple
\emph default
 shallow trees by hand that could reliably defeat a reasonable portion of
 the hand-coded bots.
 
\end_layout

\begin_layout Standard
Finally, we augmented the traditional tree creation to support 
\begin_inset Formula $n$
\end_inset

 generations of random tree creation before starting reproduction.
 This augmentation is described below:
\end_layout

\begin_layout Enumerate
Let 
\begin_inset Formula $G=0$
\end_inset

 be the current generation, 
\begin_inset Formula $R=0$
\end_inset

 be the current random generation, and 
\begin_inset Formula $P$
\end_inset

 be the population size
\end_layout

\begin_layout Enumerate
Generate initial random population of size 
\begin_inset Formula $P$
\end_inset

 
\end_layout

\begin_layout Enumerate
Evaluate the fitness of all individuals
\end_layout

\begin_layout Enumerate
\begin_inset Formula $G\leftarrow G+1$
\end_inset

 and 
\begin_inset Formula $R\leftarrow R+1$
\end_inset


\end_layout

\begin_layout Enumerate
While 
\begin_inset Formula $R<R_{max}$
\end_inset

 do:
\end_layout

\begin_deeper
\begin_layout Enumerate
Pick the best 
\begin_inset Formula $R$
\end_inset

 individuals from the current population
\end_layout

\begin_layout Enumerate
Randomly create 
\begin_inset Formula $P-R$
\end_inset

 new individuals
\end_layout

\begin_layout Enumerate
Evaluate the fitness of all individuals
\end_layout

\begin_layout Enumerate
\begin_inset Formula $G\leftarrow G+1$
\end_inset

 and 
\begin_inset Formula $R\leftarrow R+1$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Begin the standard GP algorithm
\end_layout

\begin_layout Standard
While relatively simple, the idea was an attempt to bootstrap the population
 with high-fitness random individuals and let evolution proceed with 
\emph on
less
\emph default
 mutation from that point onward.
 All of this was based on our perception that we didn't have enough good
 genetic material in the first place, and the genetic material we did have
 wasn't being utilized well.
\end_layout

\begin_layout Standard
The good news from these changes was that with only half the generations
 of the first round, we achieved higher fitness, better scan efficiency,
 almost optimal firing accuracy, and just over 6.8 times the average bullet
 damage.
 The bad news is that since we augmented the algorithm and changed so many
 parameters, it's quite impossible to tell what contributed to the overall
 improvement.
 There are, however, still some issues with the results of this run.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename fitness_2.pdf
	scale 50
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:fit2}

\end_inset

Minimum, maximum and average fitness over 600 generations after parameter
 modifications
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first issue in question is the high frequency fluctuations in the maximum
 fitness; while the first run also exhibited fluctuations, they were not
 as pronounced.
 We have seen other coevolutionary results with high-frequency fluctuations
 (
\begin_inset LatexCommand \cite{cliff95tracking,watson01coevolutionary}

\end_inset

), but never with as large an amplitude variation as seen here.
 Our primary explanation (again, after observing random agent behaviors
 from the last 100 generations) is that the scan efficiency component of
 the fitness function is the main culprit (see the similarities between
 Figures 
\begin_inset LatexCommand \ref{fig:fit2}

\end_inset

 and 
\begin_inset LatexCommand \ref{fig:scan2}

\end_inset

), and the developed behavior of the agents indicates a scanning trait that
 initially scans only the first quadrant relative to the agent's position.
 If an opponent is detected during this scan, the agent usually turns to
 face the enemy using the entire platform (i.e.
 body, turret and radar), fixes the radar in place, and then tracks the
 enemy (thus leading to low radar scan radians, but lots of enemy scan events).
 However, due the stochastic nature of the starting positions and orientations,
 if an agent does not initially scan an opponent, it will often do nothing,
 leading to a very low scanning efficiency.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename progress_2.pdf
	scale 50

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:progress2}

\end_inset

Progress of the agents against the human-coded bots after parameter modification.
 Both the maximum number of bot types beaten and total percentage of agent
 wins against bots are shown.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename scan2.pdf
	scale 50

\end_inset


\end_layout

\begin_layout Caption
Scan Efficiency after parameter modification
\begin_inset LatexCommand \label{fig:scan2}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename firing2.pdf
	scale 50

\end_inset


\end_layout

\begin_layout Caption
Firing Accuracy after parameter modification
\begin_inset LatexCommand \label{fig:fire2}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename bullet_damage2.pdf
	scale 50

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:bull2}

\end_inset

Bullet damage after parameter modification
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename dist_travelled2.pdf
	scale 50

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:dist2}

\end_inset

Distance travelled after parameter modification
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of more concern however, is the progress of the agents with respect to our
 set of human-coded opponents.
 Since the ultimate goal of this research is to evolve agents that can compete
 successfully, this is our 
\begin_inset Quotes eld
\end_inset

real-world fitness
\begin_inset Quotes erd
\end_inset

, or as Watson and Pollack make the distinction, our 
\emph on
objective
\emph default
 fitness 
\begin_inset LatexCommand \cite{watson01coevolutionary}

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Standard
The 
\emph on
subjective
\emph default
 fitness would be our exogenous fitness.
\end_layout

\end_inset

.
 As Figure\InsetSpace ~

\begin_inset LatexCommand \ref{fig:progress2}

\end_inset

 shows, while we have done better than the first run, we are still not doing
 too well overall.
 In fact, the graph shows a decline beginning around generation 475 and
 continuing until the end.
 What happened to the genetic material that allowed the agents around generation
 100 to defeat up to 5 of the progress bots? We believe that Robocode itself,
 along with Figures 
\begin_inset LatexCommand \ref{fig:bull2}

\end_inset

 and 
\begin_inset LatexCommand \ref{fig:dist2}

\end_inset

 hold the answers.
 
\end_layout

\begin_layout Standard
To address the decline: notice that at around generation 200, the bullet
 damage essentially stabilizes at around an average of 880 (see Figure\InsetSpace ~

\begin_inset LatexCommand \ref{fig:bull2}

\end_inset

).
 This in itself is not that great, since bullet damage is a good indication
 of an ability to damage the other player, as we see in the progress graph.
 If it stops going up - we're not learning how to do more damage.
 But combine this with the distance travelled in Figure\InsetSpace ~

\begin_inset LatexCommand \ref{fig:dist2}

\end_inset

, and we see that the agents begin to move more in the last 100 generations,
 while scan efficiency drops some.
 Firing accuracy is almost optimal, so it seems counterintuitive for a drop
 in performance.
 However, our reasoning is that the agents are not firing when moving (since
 they haven't developed any predictive firing capabilities), but while moving
 they give the human-coded bots a chance to attack and cause more damage.
\end_layout

\begin_layout Standard
Finally, the loss of genetic material is basically a red herring.
 Having tested the agents purported to beat one of the human-coded champion
 bots, we found that it couldn't have been true.
 This is quite unfortunate, because it points to some possible problems:
 either Robocode itself has a bug that allows our agent to win every once
 in a while given the stochastic initialization of rounds, or our modifications
 of Robocode have introduced a similar bug.
 Having seen and worked with the innards of Robocode, our money is that
 therein lies the bug.
 However, all is not lost, and our results are not completely void.
 Compared to a number of the simpler human-coded bots (as recorded in our
 progress battles log) our agents do win, and this has been verified by
 running them interactively in Robocode.
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
So, what do these results mean?
\end_layout

\begin_layout Subsubsection
Evolution by fitness function
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
As intended, the exogenous fitness function 
\family default
\series bold
\shape default
\size default
\emph default
\bar default
\noun default
is
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
 guiding the evolution of the GP agnets.
 However, it did not guide it in quite the direction we intended: unfortunately,
 we did not design a fitness function that evolved an effectively competitive
 agent.
 Some aspects of good behavior did appear, such as efficient scanning enemy
 scanning, but other behaviors did not evolve well or at all.
\end_layout

\begin_layout Standard
Scanning efficiency was elevated due to its emphasis in the fitness, therefore
 some observed scanning behavior is excellent if not always consistent.
 However, the scan efficiency scores were much larger than expected (and
 thus dominated all other factors) due primarily to an unforseen development:
 agents learned to greatly reduce the movement of their radar and to seek
 their opponent largely through body motion.
 This allowed them to track and obtain scan events, while essentially never
 rotating their scanner.
 Future implementations of the fitness function will have to take this into
 consideration.
 When we designed the final fitness function, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
we believed a good scanning technique would produce at least 4 scan events
 per radar rotation.
 As evidenced by Figure\InsetSpace ~

\begin_inset LatexCommand \ref{fig:scan2}

\end_inset

, we were wrong.
 
\end_layout

\begin_layout Standard
Another aspect of agent behavior that appears to have evolved well is shot
 accuracy.
 As shown in Figure\InsetSpace ~

\begin_inset LatexCommand \ref{fig:fire2}

\end_inset

, over the last 150 generations the agents were hitting with an average
 of 80 percent of their shots.
 However, this does not mean that the agents developed any sort of robust
 targeting algorithm; rather, they seemed to be benefitting from immobile
 opponents.
 If the opponent does not move, then it is trivial to hit it.
 Also, they'd only have to fire a few shots to get a good efficiency.
 However, this tactic is balanced by the need to do actual damage.
\end_layout

\begin_layout Standard
Motion is an agent behavior that did not evolve so well under the final
 fitness function since there was no explicit motivation to move.
 In general, the agents
\end_layout

\begin_layout Itemize
liked to back up a lot (that works in with scan efficiency and bullet damage,
 since as they back up, they can full-body track an opponent and fire at
 the same time)
\end_layout

\begin_layout Itemize
vibrate back and forth between 0 and ~35 degrees (scanning that arc without
 moving the radar)
\end_layout

\begin_layout Itemize
get stuck a lot (no explicit sensor or memory indicating 
\begin_inset Quotes eld
\end_inset

stuckness
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

stuck
\begin_inset Quotes erd
\end_inset

 can be defined as against the wall, in a corner, or against an opponent
 that prevents them from turning or moving in their desired direction
\end_layout

\end_deeper
\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Some portion of the movement faults are due in part from omissions in the
 fitness function, such as failing to penalize wall hits, while other seem
 to be cause by deficiencies in the representation; i.e.
 the nodes do not provide the tools needed for the agents to fully determine
 their state and respond appropriately.
 Theoretically evolution should work around those limitations
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\SpecialChar \ldots{}
 but in our experiment, that doesn't work due to an incomplete fitness function.
\end_layout

\begin_layout Standard
For example, maybe the fitness doesn't emphasize the survival enough.
 Why should it? Quite possibly so the agents can dodge and stay alive long
 enough to have a chance at damaging the opponent.
 When observing the best evolved agents against the best human-coded bots
 it becomes painfully obvious: e.g.
 Dookious continuously moves in a wave movement and accurately fires at
 an evolved agent that for more than half the time will not attempt to dodge
 the bullets; and there are sufficient nodes to determine that information
 and react in some manner.
\end_layout

\begin_layout Standard
The primary motivation for using an exogenous fitness function was to enable
 us to instill combative behaviors in the robots.
 We did not succeed in our ambitious goal.
 However, we must state that our agents are 
\series bold
not
\series default
 catatonic (as reported by others, i.e.
 Eisenstein 
\begin_inset LatexCommand \cite{Eisenstein:2003wd}

\end_inset

).
 While in general our agents don't always seek out other agents and instead
 rely on the stochasm of the round placements, some will react in appropriate
 ways if they scan an opponent or are attacked, and this does enable them
 to beat some very simple human-coded bots.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
On the other side of the coin (the negative side, if one does exist), the
 behavior of the bots depends on the interaction of their state/perceptions
 and their trees, which is obvious, but random runs can produce different
 events that lead to different state histories.
 Thus, for our agents and fitness function, we see this lead to wildly variable
 outcomes.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
 For example, it is possible to get a particularly good configuration of
 GP agents (i.e., one stuck in the corner and the other able to see and attack
 the first) that particularly inflates our fitness.
 However, if the initial conditions do not inspire one agent or the other
 to make a first action, the agents will sit there until Robocode arbitrarily
 kills them.
\end_layout

\begin_layout Subsubsection
Agent behavior
\end_layout

\begin_layout Standard
An implication of the observed results is that the behavior generated by
 the trees is very brittle.
 Small changes in the event histories 
\begin_inset Foot
status collapsed

\begin_layout Standard
Not to mention damage from crossover and mutation
\end_layout

\end_inset

, can make an agent essentially non-functional.
 We believe this is evidenced by the fact that the min fitness is always
 very close to zero.
 One contributing factor to this phenomenon (hinted at above) is that the
 GP agents have no explicit memory.
 That is, they remember nothing before their most recent set of events and
 measurements.
 
\end_layout

\begin_layout Standard
One aspect of agent behavior we can't explain is the similarity among individual
s at the end of the run.
 We saw this effect in both runs, even when the mutation rate was high.
 The only explanation we have for now is that the fitness drives the scan
 efficiency so hard that an early high-performing radar tree is elevated
 and becomes the only genetic trait left to the population.
 It seems a form of convergence, and it probably is, but only 
\end_layout

\begin_layout Subsubsection
Our deficiencies
\end_layout

\begin_layout Standard
One significant mistake that we appear to have made is in choosing to use
 a single population.
 The majority of the literature considers coevolution in the context of
 multiple populations often performing two different roles but with each
 affecting the others fitness landscape.
 Because we were not using multiple populations, it wasn't apparent how
 we could make use of many of the coevolutionary techniques that are described
 in 
\begin_inset LatexCommand \cite{dejong2004iec}

\end_inset

 or 
\begin_inset LatexCommand \cite{cliff95tracking}

\end_inset

.
 We believe this has adversely affected our results.
\end_layout

\begin_layout Standard
In Cliff and Miller's paper, they discuss issues and techniques that seem
 to directly apply to our issues and observations, for example:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Instantaneous fitness tells us little
\begin_inset Quotes erd
\end_inset

---Essentially, it's not clear that simply plotting the instantaneous fitness
 at every generation is sufficient to garner the information we need to
 determine success or failure of the evolution.
 They present the term 
\begin_inset Quotes eld
\end_inset

fitness ambiguities
\begin_inset Quotes erd
\end_inset

 to refer to situations where one may be able to interpret results as both
 success or failure, but is unable to know definitively.
 This arises due to the 
\begin_inset Quotes eld
\end_inset

Red Queen effect
\begin_inset Quotes erd
\end_inset

: the fitness landscape continuously changes as a result of the populations
 simultaneous changes within that landscape.
\end_layout

\begin_layout Itemize
CIAO: the Current Individual vs.
 Ancestral Opponents measure.
 This is a mechanism that directly mirrors its name: evaluate the current
 population of individuals against its past set of opponents, generally
 up to some 
\begin_inset Formula $n$
\end_inset

 generations prior.
 This can give indications about whether the evolution is actually progressing
 or degressing.
\end_layout

\begin_layout Standard
If we had known more about some of the issues with coevolution that have
 plagued researchers in the past, like focussing 
\begin_inset LatexCommand \cite{watson01coevolutionary}

\end_inset

, disengagement, and learning-and-forgetting 
\begin_inset LatexCommand \cite{Bader-Natal:2005fk}

\end_inset

, we may have been more careful of monitoring progress which would have
 provided more opportunities for exploring the parameter space.
\end_layout

\begin_layout Subsubsection
Our Open Questions
\end_layout

\begin_layout Enumerate
Can coevolution in general succeed in multi-dimensional one-population competiti
ve environments without outside influence?
\end_layout

\begin_layout Enumerate
Does this environment 
\emph on
need
\emph default
 the insertion of external human-coded bots to drive fitness adjustments?
\end_layout

\begin_layout Enumerate
How do we modify the fitness function to improve behavior? Essentially,
 it seems that one might think of the fitness function as defining how a
 battle should occur given our domain knowledge.
 Thus, the question is how to encode the modelled outcome?
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Standard
Although this experiment was not immediately successful, it does point the
 way towards many interesting future investigations.
 
\end_layout

\begin_layout Enumerate
Continue experimenting with the exogenous fitness function, the node set,
 population size, and the reproduction parameters in an attempt to succeed
 with the coevolutionary approach.
 
\end_layout

\begin_layout Enumerate
Incorporate the results from the progress measurement rounds into the selection
 process.
\end_layout

\begin_layout Enumerate
Replace the single population model with a dual population model and investigate
 the efficacy of the evaluation approaches specified in 
\begin_inset LatexCommand \cite{dejong2004iec}

\end_inset

 or 
\begin_inset LatexCommand \cite{Bader-Natal:2005fk}

\end_inset

.
\end_layout

\begin_layout Enumerate
Modify the driver program to limit the size of the trees.
 This will should reduce execution times and code bloat.
\end_layout

\begin_layout Enumerate
Address some of the open questions\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
There is no guarantee that any of these efforts would result in success.
 However, should they all fail it would give greater credence to the idea
 that coevolution of a human-competitive Robocode agent is not possible.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
We must regretfully admit that we did not prove our hypothesis.
 We were not able to evolve competitive Robocode tanks through coevolution
 using an exogenous fitness function.
 That said, this experiment did not show the hypothesis false.
 It is not apparent that coevolution of competitive Robocode tanks cannot
 succeed.
 We simply have not found a way to cause it to happen.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \bibtex[plain]{refs}

\end_inset


\end_layout

\end_body
\end_document
